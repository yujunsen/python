{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": [" \n                     \n                    ", "小程序", "全局配置app.josn增加选项：\"navigationStyle\": \"custom\",", "具体如下：", "原生小程序开发", "打开 app.json：", "{", "    ", "\"pages\"", ":", " ", "[", "        ", "\"pages/index/index\"", ",", "        ", "\"pages/logs/index\"", "    ", "],", "    ", "\"window\"", ":", " ", "{", "        ", "\"backgroundTextStyle\"", ":", " ", "\"light\"", ",", "        ", "\"navigationBarBackgroundColor\"", ":", " ", "\"#000\"", ",", "        ", "\"navigationStyle\"", ":", " ", "\"custom\"", ",", "        ", "\"navigationBarTitleText\"", ":", " ", "\"WeChat\"", "    ", "}", "}", "mpvue方式开发小程序>", "打开 /src/main.js：", "export", " ", "default", " ", "{", "  config", ":", " ", "{", "    pages", ":", " ", "[", "      ", "'pages/logs/main'", ",", "      ", "'^pages/index/main'", "　　", "],", "    window", ":", " ", "{", "      backgroundTextStyle", ":", " ", "'light'", ",", "      navigationBarBackgroundColor", ":", " ", "'#666'", ",", "      navigationStyle", ":", " ", "'custom'", ",", "      navigationBarTitleText", ":", " ", "'WeChat'", ",", "      navigationBarTextStyle", ":", " ", "'#fff'", ",", "      enablePullDownRefresh", ":", " ", "false", ",", "      disableScroll", ":", " ", "true", "    ", "}", "  ", "}", "}", " "]}
{"title": "在小程序中集成redux/immutable/thunk第三方库", "author": "Rolan", "pub_time": "2018-8-13 00:04", "content": [" \n                     \n                    ", "小程序", "给我们暴露了两个参数 ", "require", " 和 ", "module", " ， ", "require", " 用来在模块中加载其他模块，", "module", " 用来将模块中的方法暴露出去", "module", ".exports = ", "function", "()", "{}\r\n", "所以只要需要让第三方库的代码使用这种形式的 ", "export", " 就可以了", "二、构建Redux的微信小程序包", "打一个 ", "Redux", " 包，让它可以兼容微信小城的加载方式", "git clone https:", "//gi", "thub.com/reactjs/redux.git\r\n\r\n", "npm", " install\r\n\r\n", "# 详细内容可以到redux项目的package.json中查看", "\r\n", "# 这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到", "\r\n", "npm", " run build:umd && ", "npm", " run build:umd\r\n", "用编辑器打开 ", "dist", " 目录下的 ", "redux.js", " 文件", "(", "function", " webpackUniversalModuleDefinition(", "root", ", factory) {\r\n    if(", "typeof", " exports === 'object' ", "&&", " typeof module === 'object')\r\n        module.exports = factory()", ";", "\r\n    else if(", "typeof", " define === 'function' ", "&&", " define.amd)\r\n        define([], factory)", ";", "\r\n    else if(", "typeof", " exports === 'object')\r\n        exports[", "\"Redux\"", "] = factory()", ";", "\r\n    else\r\n        root[", "\"Redux\"", "] = factory()", ";", "\r\n})(", "this", ", function() {\r\n...  \r\n})\r\n", "这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。", "如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来", "将第二行代码： ", "if(typeof exports === 'object' && typeof module === 'object')", " 修改成： ", "if(typeof module === 'object')", "这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入", "我们拷贝到 ", "libs", " 目录下，那么我们在程序中使用时，只要当做是一个本地模块去 ", "require", "就可以了 ", "var redux = require('./libs/redux.js')", "我们可以通过类似的方法，使用 ", "Webpack", " 打包第三方库，就可以集成任何库了", "三、集成Redux-devtools", "因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装 ", "redux-devtool", " 的插件", "安装remote-redux-devtools", "原版的 ", "remote-redux-devtools", " 使用的一个 ", "websocket", " 的依赖会使用原生的 ", "WebSocket", " ，小程序是不支持的，所以需要改成小程序的 ", "websocket", " 实现,修改好的代码 ", "https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/remote-redux-devtools.js", "把代码下载到工程目录里面就可以用了", "安装和启动remotedev-server", "npm ", "install", " -g remotedev-", "server", "\r\nremotedev ", "--hostname=localhost --port=5678", "\r\n", "因为没办法用 ", "npm", " 安装到本地（微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动 ", "remotedev-server", " ， ", "hostname", " 和 ", "port", " 分别指定为 ", "localhost", "和 ", "5678", "集成devtool", "在 ", "store", " 下集成 ", "devtool", "const", " {createStore, compose} = ", "require", "(", "'./libs/redux.js'", ");\r\n", "const", " devTools = ", "require", "(", "'./libs/remote-redux-devtools.js'", ").", "default", ";\r\n", "const", " reducer = ", "require", "(", "'./reducers/index.js'", ")\r\n\r\n", "function", " ", "configureStore", "()", " ", "{\r\n  ", "return", " createStore(reducer, compose(devTools({\r\n    hostname: ", "'localhost'", ",\r\n    port: ", "5678", ",\r\n    secure: ", "false", "\r\n  })));\r\n}\r\n\r\nmodule.exports = configureStore;\r\n", "把 ", "devtool", " 使用 ", "redux", " 的 ", "compose", " 加到 ", "store", " 中去。 ", "hostname", " 和 ", "port", " 是指定为之前启动 ", "remotedev-server", " 启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了", "可以在浏览器中访问 ", "localhost:5678", "四、小程序中集成immutable", "Immutable", " 是 ", "Facebook", " 开发的不可变数据集合。不可变数据一旦创建就不能被修改，是的应用开发更简单，允许使用函数式编程技术，比如惰性评估。微信小程序无法直接使用 ", "Immutable.js", " ，下面就来说说微信小程序如何使用第三方库 ", "Immutable.js", "Immutable使用了UMD模块化规范", "(", "function", " (", "global", ", factory) {\r\n typeof exports === ", "'object", "' && typeof module !== ", "'undefined", "' ? module.exports = factory() :\r\n typeof define === ", "'function", "' && define.amd ? define(", "factory", ") :\r\n (", "global.Immutable", " = factory())", ";", "\r\n}(", "this", ", function () { ", "'use", " strict'", ";var SLICE$0 = Array.prototype.slice;", "\r\n\r\n....\r\n\r\n}))", ";", "\r\n", "修改 ", "Immutable", " 代码，注释原有模块导出语句，使用 ", "module.exports = factory()", " 强制导出", "(", "function", "(", "global", ", factory) {\r\n /*\r\n typeof exports === ", "'object", "' && typeof module !== ", "'undefined", "' ? module.exports = factory() :\r\n typeof define === ", "'function", "' && define.amd ? define(", "factory", ") :\r\n (", "global.Immutable", " = factory())", ";", "\r\n */\r\n\r\n module.exports = factory()", ";", "\r\n\r\n}(", "this", ", function() {\r\n", "导入修改好的 ", "immutable", " 到小程序中即可 ", "https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/immutable.js", " "]}
{"title": "小程序 textarea组件层级过高导致文字穿透浮层的一个解决方法 ... ...", "author": "Rolan", "pub_time": "2018-8-13 00:19", "content": [" \n                     \n                    ", "最近做的一个", "小程序", "需求，其中一个页面使用到了 ", "textarea", "这个小程序组件，然后点击页面上的某个元素，会触发页面弹起一个弹窗，这时发现 ", "textarea", "的 ", "placeholder", "文字或者输入的文字内容，会直接穿透遮罩层和浮动弹窗，显示在最上面，开始时我以为是遮罩层和浮动弹窗的层级舍得小了，于是改大，谁知道没用，改到了 ", "99999", "也没用，于是我意识到这应该不是我代码的问题，网上一搜，果然有故事。", "\r\n", "\r\n", "解决方案", "\r\n", "\r\n", "隐藏 ", "textarea", "\r\n", "\r\n", "这是最简单的解决手段，一般弹窗的时候，都会带个遮罩层，把遮罩层下面的内容隐藏一部分，用户基本上不会注意的，然后再去掉弹窗和遮罩层的时候再把 ", "textarea", "显示出来。\r\n这种方法简单有效，大部分情况下都可以这么解决。", "\r\n", "<", "textarea", " ", "wx:if", "=", "\"{{ showMask }}\"", ">", "textarea", ">\r\n", "复制代码", "\r\n", "使用替代元素", "\r\n", "\r\n", "有时候， ", "textarea", "穿透的不是遮罩层，或者遮罩层以一种半透明而非完全遮住页面内容的形式呈现，担心用户能够看到因为 ", "textarea", "的消失而导致页面跳动，产生不好的用户体验，那么就可以使用替代元素来替代 ", "textarea", "而非将之直接隐藏掉。", "\r\n", "基本的 ", "textarea", "组件只接受文本的输入，抛开可输入性的话，外观上看就是一个含有文本节点的简单元素，只需要获取当前状态下的 ", "textarea", "中输入的文字，将之赋予给一个样式与 ", "textarea", "相同的普通元素，就达到了临时替代的效果。", "\r\n", "\r\n", "<", "textarea", " ", "id", "=", "\"text-area\"", " ", "value", "=", "\"{{txtRealContent}}\"", " ", "bindinput", "=", "'txtInput'", " ", "wx:if", "=", "\"{{!showMask}}\"", " />", "\r\n", "\r\n", "<", "view", " ", "class", "=", "'rich-text'", " ", "style", "=", "\"{{('height:' + txtHeight + 'px')}}\"", " ", "wx:else", ">", "\r\n  ", "<", "rich-text", " ", "nodes", "=", "\"{{txtRealContent}}\"", ">", "rich-text", ">\r\n", "view", ">\r\n", "复制代码", "如上所示", "\r\n", "\r\n", "由于需要实时获取 ", "textarea", "中已经输入的内容，所以给 ", "textarea", "元素加了个 ", "bindinput", "的监听器", "\r\n", "showMask", "用于标识是否显示遮罩层(或者其他可能会被 textarea穿透的浮动元素)，如果显示遮罩层，则隐藏 ", "textarea", "元素，并显示替代原宿", "\r\n", "这里 ", "textarea", "的隐藏使用了 ", "wx:if", "，会使其彻底地从页面中消失，而重新显示出来的时候，", "textarea", "元素会重新创建，丢失原先输入，所以给其加了个 ", "value", "属性，其值 ", "txtRealContent", "就是缓存的 ", "textarea", "已经输入的文本内容；如果你不用这种方法，不让 ", "textarea", "完全显示，而仅仅是隐藏，例如使用 ", "hidden=\"{{ showMask ? true :false }}\"", "，因为不涉及到 ", "textarea", "的删除与重建，所以就无需添加 ", "value", "属性来控制文本内容了。", "\r\n", "textarea", "是可以输入可换行的文本内容的，所以这里使用了 ", "rich-text", "组件，在使用的时候，我发现 ", "rich-text", "好像不支持溢出隐藏，所以又额外在其外面包了一层 ", "view", "组件，并将其高度设置为和 ", "textarea", "相同", "\r\n", "\r\n", "上面四个步骤，都比较简单，稍微需要注意的是，如果 ", "textarea", "的内容包含了换行文本，则需要对换行符进行处理：", "\r\n", "textareaContent.replace(", "/\\n/g", ", ", "'", "'", ")\r\n", "复制代码", "如果你想让 ", "textarea", "自动增加高度而不是固定高度，给 ", "textarea", "加了个 ", "auto-height", "，那么就需要“实时”获取其高度\r\n说是 “实时”，其实也并不是那么实时，不考虑其他样式的变化， ", "textarea", "的高度与行数有关，每增减一行，其高度才会变化，所以只需要监控其内容行数的变化即可，恰好 ", "textarea", "组件也已经提供了这个监控器：", "bindlinechange", "。", "\r\n", "\r\n", "\r\n", "原理说完了，完整实例代码如下：", "\r\n", "index.wxml", "\r\n", "<", "view", " ", "class", "=", "\"page-body\"", ">", "\r\n  ", "<", "button", " ", "bindtap", "=", "\"changeMaskVisible\"", ">", "切换mask", "button", ">\r\n  ", "<", "view", " ", "class", "=", "\"textarea-wrp\"", ">", "\r\n    ", "<", "textarea", " ", "id", "=", "\"text-area\"", " ", "value", "=", "\"{{txtContent}}\"", " ", "bindinput", "=", "'txtInput'", " ", "bindlinechange", "=", "\"textAreaLineChange\"", " ", "wx:if", "=", "\"{{!showMask}}\"", " ", "auto-height", " />", "\r\n    ", "<", "view", " ", "class", "=", "'rich-text'", " ", "style", "=", "\"{{('height:' + txtHeight + 'px')}}\"", " ", "wx:else", ">", "\r\n      ", "<", "rich-text", " ", "nodes", "=", "\"{{txtRealContent}}\"", ">", "rich-text", ">\r\n    ", "view", ">\r\n  ", "view", ">\r\n  ", "<", "button", ">", "Footer", "button", ">\r\n  ", "<", "view", " ", "wx:if", "=", "\"{{showMask}}\"", " ", "bindtap", "=", "\"changeMaskVisible\"", " ", "class", "=", "\"mask\"", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"mask-content\"", ">", "view", ">    \r\n  ", "view", ">\r\n", "view", ">\r\n", "复制代码", "index.js", "\r\n", "Page({\r\n  ", "data", ": {\r\n    ", "txtRealContent", ": ", "''", ",\r\n    ", "txtContent", ": ", "''", ",\r\n    ", "showMask", ": ", "false", ",\r\n    ", "txtHeight", ": ", "0", "\r\n  },\r\n  textAreaLineChange(e) {\r\n    ", "this", ".setData({ ", "txtHeight", ": e.detail.height })\r\n  },\r\n  txtInput(e) {\r\n    ", "this", ".setData({ ", "txtContent", ": e.detail.value })\r\n  },\r\n  changeMaskVisible(e) {\r\n    ", "if", " (!", "this", ".data.showMask) {\r\n      ", "// 将换行符转换为wxml可识别的换行元素 ", "\r\n      ", "const", " txtRealContent = ", "this", ".data.txtContent.replace(", "/\\n/g", ", ", "'", "'", ")\r\n      ", "this", ".setData({ txtRealContent })\r\n    }\r\n    ", "this", ".setData({ ", "showMask", ": !", "this", ".data.showMask })\r\n  }\r\n})\r\n", "复制代码", "index.wxss", "\r\n", ".rich-text", " {\r\n  ", "overflow", ": hidden;\r\n}\r\n", ".mask", " {\r\n  ", "position", ": fixed;\r\n  ", "top", ": ", "0", ";\r\n  ", "right", ": ", "0", ";\r\n  ", "bottom", ": ", "0", ";\r\n  ", "left", ": ", "0", ";\r\n  ", "background-color", ": ", "rgba", "(0, 0, 0, .6);\r\n  ", "z-index", ": ", "10", ";\r\n}\r\n", ".mask-content", " {\r\n  ", "position", ": fixed;\r\n  ", "top", ": ", "44%", ";\r\n  ", "left", ": ", "50%", ";\r\n  ", "height", ": ", "60%", ";\r\n  ", "width", ": ", "60%", ";\r\n  ", "transform", ": ", "translate", "(-50%, -50%);\r\n  ", "background-color", ": yellowgreen;\r\n  ", "z-index", ": ", "12", ";\r\n}", "作者：清夜", "链接：https://juejin.im/post/5b6ab1f951882539766ea558", " "]}
{"title": "微信小程序与AspNetCore SignalR聊天实例", "author": "Rolan", "pub_time": "2018-8-8 00:19", "content": [" \n                     \n                    ", "本文不对", "小程序", "与signalr做任何介绍,默认读者已经掌握", "aspnetcore Signalr文档", "小程序文档", "写在之前", "SignalR没有提供小程序使用的客户端js,所以本人参考signlar.js写了小程序版signalr-client.js 代码开源，地址 ", "https://github.com/liangshiw/SignalRMiniProgram-Client", "先上效果图", "开始编码", "首先需要创建一个aspnetcore的mvc项目，创建完成后我们需要安装signalr的包", " ", "Install-Package", " ", "Microsoft", ".AspNetCore", ".SignalR", "现在就可以创建hub集线器了,首先定义一个类来描述已在线的用户,它需要头像和姓名", "public", " ", "class", " ", "OnlineClient", "\r\n{\r\n   ", "public", " ", "string", " NickName { ", "get", "; ", "set", "; }\r\n\r\n   ", "public", " ", "string", " Avatar { ", "get", "; ", "set", "; }\r\n}\r\n", "接下来我们在连接创建时，把当前用户做为在线用户添加到字典中,向该用户发送加入成功的系统消息。并且同时向其他的用户发送系统消息", "public", " ", "override", " ", "async", " Task ", "OnConnectedAsync", "(", ")\r\n", "{\r\n    ", "var", " http = Context.GetHttpContext();\r\n\r\n    ", "var", " client = ", "new", " OnlineClient()\r\n    {\r\n         NickName = http.Request.Query[", "\"nickName\"", "],\r\n         Avatar = http.Request.Query[", "\"avatar\"", "]\r\n    };\r\n\r\n    ", "lock", " (SyncObj)\r\n    {\r\n        OnlineClients[Context.ConnectionId] = client;\r\n    }\r\n\r\n    ", "await", " ", "base", ".OnConnectedAsync();\r\n    ", "await", " Groups.AddToGroupAsync(Context.ConnectionId, ChatName);\r\n    ", "await", " Clients.GroupExcept(ChatName, ", "new", "[] { Context.ConnectionId }).SendAsync(", "\"system\"", ", $", "\"用户{client.NickName}加入了群聊\"", ");\r\n    ", "await", " Clients.Client(Context.ConnectionId).SendAsync(", "\"system\"", ", $", "\"成功加入{ChatName}\"", ");\r\n\r\n }", "同样在用户断开连接时做离线处理", "public", " ", "override", " ", "async", " Task ", "OnDisconnectedAsync", "(", "Exception exception", ")\r\n", "{\r\n\r\n    ", "await", " ", "base", ".OnDisconnectedAsync(exception);\r\n\r\n    ", "bool", " isRemoved;\r\n    OnlineClient client;\r\n    ", "lock", " (SyncObj)\r\n    {\r\n        isRemoved = OnlineClients.TryRemove(Context.ConnectionId, ", "out", " client);\r\n\r\n\r\n    }\r\n    ", "await", " Groups.RemoveFromGroupAsync(Context.ConnectionId, ChatName);\r\n\r\n    ", "if", " (isRemoved)\r\n    {\r\n        ", "await", " Clients.GroupExcept(ChatName, ", "new", "[] { Context.ConnectionId }).SendAsync(", "\"system\"", ", $", "\"用户{client.NickName}退出了群聊\"", ");\r\n    }\r\n\r\n}  \r\n", "下面就只有一个简单的发送消息方法了,首先查看当前用户是否在线并做相应处理,如果在线就把当前用户的消息和头像姓名一起发送给组中的其他客户端", " ", "public", " ", "async", " Task ", "SendMessage", "(", "string", " msg", ")\r\n", "{\r\n    ", "var", " client = OnlineClients.Where(x => x.Key == Context.ConnectionId).Select(x=>x.Value).FirstOrDefault();\r\n    ", "if", " (client == ", "null", ")\r\n    {\r\n        ", "await", " Clients.Client(Context.ConnectionId).SendAsync(", "\"system\"", ", ", "\"您已不在聊天室,请重新加入\"", ");\r\n    }\r\n    ", "else", "\r\n    {\r\n        ", "await", " Clients.GroupExcept(ChatName, ", "new", "[] { Context.ConnectionId }).SendAsync(", "\"receive\"", ", ", "new", " { msg, nickName = client.NickName, avatar = client.Avatar });\r\n\r\n    }\r\n}", "在小程序中，我们需要在页面加载事件中创建与signalr的连接，并且注册system系统消息与receive用户消息两个方法以接收服务端发来的消息", "onLoad: ", "function", " (", "options", ") ", "{\r\n  \r\n    ", "this", ".hubConnect = ", "new", " Hub.HubConnection();\r\n\r\n    ", "this", ".hubConnect.start(", "\"https://chat.jingshonline.net/chat\"", ", { nickName: app.globalData.userInfo.nickName, avatar: app.globalData.userInfo.avatarUrl });\r\n    ", "this", ".hubConnect.onOpen = res => {\r\n      ", "console", ".log(", "\"成功开启连接\"", ")\r\n    }\r\n\r\n    ", "this", ".hubConnect.on(", "\"system\"", ", res => {\r\n      wx.showModal({\r\n        title: ", "'系统消息'", ",\r\n        content: res,\r\n      })\r\n    })\r\n\r\n    ", "this", ".hubConnect.on(", "\"receive\"", ", res => {\r\n      centendata.push({\r\n        content: res.msg,\r\n        time: ", "new", " ", "Date", "().toLocaleString(),\r\n        head_owner: res.avatar,\r\n        is_show_right: ", "0", "\r\n      });\r\n      ", "this", ".setData({\r\n        centendata: centendata\r\n      })\r\n    })\r\n  }", "同样在页面销毁时应断开与signalr服务器的连接", "onUnload: ", "function", " (", ") ", "{\r\n  ", "this", ".hubConnect.close({ reason: ", "\"退出\"", " })\r\n}", "发送方法也非常简单,只需要调用sendMessage方法并把用户输入的消息传入就大功告成了，其它就是页面上的处理了", "this", ".hubConnect.send(", "\"sendMessage\"", ",message);", "完整的代码请去github ", "https://github.com/liangshiw/SignalRMiniProgram-Client/tree/master/sample", "需要注意的是在打开小程序代码时，请修改project.config.json文件中的appid,如果项目不错的话还请大家加个星,顺便再follow一下本人", " "]}
{"title": "初试小刀自我简历小程序", "author": "Rolan", "pub_time": "2018-8-8 00:12", "content": [" \n                     \n                    ", ">>>点击获取更多文章<<<", "最近在做", "小程序", "，和域名更换，和新域名备案事情，甚是较忙，少写了文章，今天尝试写一篇小白总结小程序的常见问题，刚接触小程序不到2周，在业余时间尝试小刀小程序，多有不足，请指出。", "附上个人简历小程序图，大家可以微信扫描体验哟。", "小程序开发资源汇总", "https://github.com/justjavac/...", "小程序开发框架", "在github里面找了找，Wepy 和mpvue比较火，毕竟Wepy是腾讯官方的开源，故我选择了Wepy。同时也选择了weui库，貌似zanui也不错，大家可以尝试下。", "幻灯片组件", "看到别人的一些小程序幻灯片图片转转转，很酷，以为是一些其他框架带来的，其实 官方自带了视图容器swiper，详情点击官方 ", "https://developers.weixin.qq....", "。", "下方的tabBar", "刚开始做的时候，以为这些都是必须写成组件，封装成UI输出，其实原生小程序已经自带了，不需要额外做，在app.json可以设置，在wepy框架是 app.wpy里面设置。", "矢量图标哪里找", "在这 ", "http://www.iconfont.cn/", " 可以找到需要的icon。", "界面样式如何适应不同手机", "毕竟是在微信内部小程序环境，如何适应不同手机是个问题，用rpx吧，这样在不同的手机可以实现自适应。所以如果你使用的模块有pxh或者rem,换算方式为：1px=2rpx，1rem=35rpx。", "内嵌html页面", "当初在做的时候也想过类似问题，其实百度了下，得知了答案，只有公司类型账号才能内置 网页<web-view src=\"", "https://www.xxxxxxxxx.com/ind...", "; />，个人账号类型不可以哟！", "在html5跳转到小程序的一个页面", "<!-- html代码中引入JS SDK -->", " \r\n", "<", "script", " ", "type", "=", "\"text/javascript\"", " ", "src", "=", "\"https://res.wx.qq.com/open/js/jweixin-1.3.0.js\"", ">", "</", "script", ">", " \r\n", "<", "script", ">", " \r\n wx.miniProgram.navigateTo({url: ", "'/path/to/page'", "}) \r\n", "</", "script", ">", "实现锚点跳转", "下面是我用wepy实现的代码(自己看重点)，其实就是用了官方视图容器", "scroll-view", "：", "<", "template", ">", "\r\n\r\n    ", "<", "scroll-view", " ", "scroll-y", "=", "\"true\"", "  ", "scroll-into-view", "=", "\"", "{{toView}}", "\"", " ", "scroll-with-animation", "=", "\"true\"", "  ", "class", "=", "\"out_scroll_view\"", ">", "\r\n        ", "<", "view", " ", "id", "=", "\"list0\"", ">", " ", "</", "view", ">", "\r\n        ", "<", "view", " ", "id", "=", "\"list1\"", ">", " ", "</", "view", ">", "\r\n        ", "<", "view", " ", "id", "=", "\"list2\"", ">", " ", "</", "view", ">", "\r\n        ", "<", "view", " ", "id", "=", "\"list3\"", ">", " ", "</", "view", ">", "\r\n        ", "<", "view", " ", "id", "=", "\"list4\"", ">", " ", "</", "view", ">", "\r\n        ", "<", "footer", ">", "</", "footer", ">", "\r\n    ", "</", "scroll-view", ">", "      \r\n\r\n    ", "<", "view", " ", "class", "=", "'right_nav'", ">", "\r\n        ", "<", "view", " ", "class", "=", "'nav_item'", " ", "wx:for", "=", "\"", "{{rightNav}}", "\"", " @", "tap", "=", "\"jumpTo(list", "{{index}}", ")\"", ">", "\r\n         ", "<", "text", " ", "class", "=", "'item_name'", ">", "{{item}}", "</", "text", ">", "\r\n        ", "</", "view", ">", "\r\n    ", "</", "view", ">", "\r\n\r\n", "</", "template", ">", "\r\n\r\n\r\n", "<", "script", ">", "\r\n    ", "import", " wepy ", "from", " ", "'wepy'", ";\r\n    ", "import", " Footer ", "from", " ", "'./common/footer'", ";\r\n\r\n\r\n    ", "export", " ", "default", " ", "class", " ", "Panel", " ", "extends", " ", "wepy", ".", "page", " ", "{\r\n\r\n        data = {\r\n            ", "rightNav", ":[", "'厂家网'", ",", "'腾讯'", ",", "'满天星'", ",", "'嵊灿'", ",", "'诺沃帝'", "],\r\n            ", "toView", ":", "''", "\r\n        };\r\n\r\n        components = {\r\n            ", "footer", ": Footer\r\n        };\r\n\r\n        methods = {\r\n\r\n        };\r\n\r\n        jumpTo(e){\r\n            ", "this", ".toView = e.currentTarget.dataset.wpyjumptoA;\r\n        };    \r\n\r\n        ", "async", " onLoad () {\r\n            wx.showShareMenu({\r\n                ", "withShareTicket", ": ", "true", "\r\n            });       \r\n        };\r\n    }\r\n", "</", "script", ">", "\r\n", "设置COOKIE", "https://blog.csdn.net/DylanCa...", "转发功能", "我记得官方有接口，可以设置展示转发按钮，或者你自身页面的UI，都可以触发转发功能，懒得找出来了，有心的自行到官方一看接口很容易找打送。 more detail look this ", "https://blog.csdn.net/rolan19...", "设置启动页面", "看①", "https://blog.csdn.net/kerryqp...", "。", "有趣功能接口", "小程序之间互跳转，拨打电话，震动电话，添加联系人，调整屏幕亮度，退出小程序，复制功能，转发功能等原生功能，都是官方有接口的，都挺有意思，大家可以进行体会。", "预览图片", "看", "https://blog.csdn.net/gao_xu_...", "，这功能是官方封装好，挺实用。", "审核上线提交", "官方文章还有有必要读下的 ", "微信小程序平台运营规范", ",", "微信小程序平台常见拒绝情形", "遗留问题和总结", "在swiper里面的图片，图片大小样式，不要给固定值，给width:100%，和height:100%，要不会出现在不同手机设备不兼容，我自身测试过；还有个问题可以分享，在工作经历tab里面， 顶部有个图片已经相对定位放在头部，然后我加了css3动画文字，整个文字块尝试过绝对定位和相对定位进行偏移到图片（图片里面的电脑屏幕上）上，自身在我安卓华为手机是可以看到动画效果的，但是在IOS手机，就是不出现，只好无奈，重新P下图片，把文字P上去； 在基本信息tab里面，有个“退出小程序”按钮功能，在IOS上，反应不是很灵敏，感觉功能不行，不知道其他开发者会不会遇到这样的问题，安卓上是可以的。", " "]}
{"title": "微信小程序实现常见的user效果", "author": "Rolan", "pub_time": "2018-8-13 00:25", "content": [" \n                     \n                    ", "用户个人页面 ", "为了便于以后的使用，所以把这个效果记录下来，以后直接复制粘贴本篇的代码。", "wxml", "<view", " ", "class", "=", "'circle'", ">", "    ", "<view", " ", "class", "=", "'userAvatar'", ">", "      ", "<open-data", " ", "type", "=", "\"userAvatarUrl\"", " ", "></open-data>", "    ", "</view>", "  ", "</view>", "代码说明： ", "open-data没有办法直接给一个class然后控制类名，但是可以通过控制外部盒子达到控制它本身的大小以及形状的目的。", "wxss", ".", "circle", "{", "  width", ":", "930rpx", ";", "  height", ":", "930rpx", ";", "  border", "-", "radius", ":", "465rpx", ";", "  background", "-", "color", ":#", "2ca6cb", ";", "  margin", "-", "top", ":-", "666rpx", ";", "  margin", "-", "left", ":-", "90rpx", ";", "  display", ":", "flex", ";", "  align", "-", "items", ":", "center", ";", "  flex", "-", "direction", ":", "column", "-", "reverse", ";", "}", ".", "userAvatar", "{", "  width", ":", "80px", ";", "  height", ":", "80px", ";", "  border", "-", "radius", ":", "40px", ";", "  margin", "-", "bottom", ":-", "30px", ";", "  overflow", ":", " hidden", ";", "}", "说明：通过flex布局控制头像的位置。", "作者：王月_92f2 ", "链接：", "https://www.jianshu.com/p/b2fd8ae61660", " ", " "]}
{"title": "小程序各种姿势实现登录", "author": "Rolan", "pub_time": "2018-8-14 00:06", "content": [" \n                     \n                    ", "喜闻乐见的背景时间--由于最近接触", "小程序", "比较多，又刚好经历过小程序的自动登录时代以及现在的点击登录时代。结合自己的实践以及观察到其他小程序的做法，就有了这篇小分享~", "本文可能涉及的内容--", "本文的小程序登录指的是什么？", "在本篇文章所讲的登录不仅仅指的是wx.login而是包括以下三点--", "获取用户基本信息", "调用微信wx.login接口", "实现服务器端登录", "我需要获取用户头像和昵称要怎么做？", "用户头像和昵称对于我们开发小程序几乎算是刚需，那么我们应该怎么样正确高效的获取&利用它们呢？", "旧时代--自动授权一把梭", "新时代--使用小程序的open-data", "使用open-data时需要注意小程序基础库的版本。具体使用方式如下", "其实可以将open-data看作图片或字符串，想要控制样式在外层加上view标签以及相应的class即可。", "相比之前获取用户基本信息的方式，这个方案还是比较走心的，如果一些小程序只是对用户的头像昵称等基本信息有需求的话就不需要和以前一样大费周章的调一个getUserInfo，拿回来一堆用不上的东西。", "我需要用户在服务器端实现登录该怎么做？", "按照微信小程序的文档，能在服务器端完成登录（获取用户session_key/openid等），有三个前端传回的参数是必不可少的：", "code", "encryptedData", "iv", "code是通过wx.login获取的，而encryptedData & iv是从wx.getUserInfo中获取的。", "但是，因为微信基础库更新，取消通过api调用getUserInfo的能力，需要使用button组件的开放能力[open-type]去调用getUserInfo方法。", "上述获取数据的方法具体建议阅读官方文档：", "有关getUserInfo的文档", "有关login的文档", "踩坑心得：请确保wx.login早于getUserInfo，不仅是代码执行层面的早，最好是login回调成功之后才去getUserInfo，不然可能会出现后端解密失败的情况，导致登录失败。", "（还可以通过API方式调用getUserInfo的时候如何实现后端登录就不在此赘述了。）", "尽管已经无法自动授权，我们还可以这样实现小程序的登录授权", "总体来说有两种授权模式，一种是强制授权，另一种则是按需授权，无论是怎么样的流程基本都可以归类为这两种授权。", "强制授权", "适用范围：对用户身份强依赖的小程序，用户一进来就必须要知道用户的相关信息，或者是用户一进来就必须根据用户id来拉取相关资源。", "授权模式：模式多种，但共同特点都是会打断用户正常进入小程序的流程，体验上有点瑕疵，在此列出两种模式：", "不跳转页面，无论点击页面中的任何地方都会弹出授权弹窗，如图所示(没有将鼠标点击录进去，实际是无论点哪都会触发授权)↓↓", "这种方案的实现方式其实很简单也很粗暴--将一个覆盖全屏的button组件以position: fixed的方式盖在需要这样登录的页面上，然后将其opacity设为0即可。", "跳转页面，检测到非登录用户则强制跳转到登录页，在里面进行登录逻辑的处理。", "就个人而言，还是比较喜欢这种授权模式的，和微信自己生态内的授权有些许相似，对用户来说不会那么突兀。", "具体实现方式--相比上一种就复杂一些了，这一种方式属于全局性质的拦截授权，会中断当前页面的所有动作，跳转至登录专用的页面，在登录页登录成功后再返回原页面。", "按需授权", "适用范围：对用户身份规划十分明确、可以接受在用户做出某些动作之后再获取用户身份的小程序。", "授权模式：不会打断小程序页面的主流程，将授权加入主流程中。实现方式也是十分灵活，无论是列表或是图片甚至是一段文字，只要是需要用户手动触发的，都可以作为授权的发起时机。", "与上述强制授权中不跳转页面的方式类似，但是有一个巨大的差异--这种方式不会强制用户授权，而是在需要授权时才会出现，相对没有这么骚扰使用小程序的用户。", " "]}
{"title": "学了这么久，vue和微信小程序到底有什么样的区别？", "author": "Rolan", "pub_time": "2018-8-13 00:18", "content": [" \n                     \n                    ", "写了vue项目和", "小程序", "，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。相比之下，小程序的钩子函数要简单得多。", "写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。", "一、生命周期", "先贴两张图：", "vue生命周期", "小程序生命周期", "相比之下，小程序的钩子函数要简单得多。", "vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。", "onLoad: 页面加载", "一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。", "onShow: 页面显示", "每次打开页面都会调用一次。", "onReady: 页面初次渲染完成", "一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。", "对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期", "onHide: 页面隐藏", "当navigateTo或底部tab切换时调用。", "onUnload: 页面卸载", "当redirectTo或navigateBack的时候调用。", "数据请求", "在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。", "二、数据绑定", "VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：", "1", ".  <img ", ":src=", "\"imgSrc\"", "/>", " \r\n复制代码", "小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：", "1.  ", "<", "image", " ", "src", "=", "\"", "{{imgSrc}", "}\"", ">", "</", "image", ">", " \r\n复制代码", "三、列表渲染", "直接贴代码，两者还是有些相似", "vue：", "1.  ", "<", "ul", " ", "id", "=", "\"example-1\"", ">", "  \r\n", "2.  ", "<", "li", " ", "v-for", "=", "\"item in items\"", ">", "  \r\n", "3.  ", "{{ item.message }}  \r\n", "4.  ", "</", "li", ">", "  \r\n", "5.  ", "</", "ul", ">", "  \r\n\r\n", "7.  ", "var example1 = new Vue({  \r\n", "8.  ", "el: '#example-1',  \r\n", "9.  ", "data: {  \r\n", "10.  ", "items: [  \r\n", "11.  ", "{ message: 'Foo' },  \r\n", "12.  ", "{ message: 'Bar' }  \r\n", "13.  ", "] \r\n", "14.  ", "}  \r\n", "15.  ", "})  \r\n\r\n复制代码", "小程序：", "1", ".  Page({  \r\n", "2", ".  data: {  \r\n", "3", ".  items: [  \r\n", "4", ".  { message: ", "'Foo'", " },  \r\n", "5", ".  { message: ", "'Bar'", " }  \r\n", "6", ".  ]  \r\n", "7", ".  }  \r\n", "8", ".  })  \r\n\r\n", "10", ".  <text wx:for=", "\"{{items}}\"", ">{{item}}</text>  \r\n\r\n复制代码", "四、显示与隐藏元素", "vue中，使用v-if 和v-show控制元素的显示和隐藏", "小程序中，使用wx-if和hidden控制元素的显示和隐藏", "五、事件处理", "vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:", "1.  ", "<", "button", " ", "v-on:click", "=", "\"counter += 1\"", ">", "Add 1", "</", "button", ">", "  \r\n2.  ", "<", "button", " ", "v-on:click.stop", "=", "\"counter+=1\"", ">", "Add1", "</", "button", ">", "  //阻止事件冒泡 \r\n\r\n复制代码", "小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：", "1.  ", "<", "button", " ", "bindtap", "=", "\"noWork\"", ">", "明天不上班", "</", "button", ">", "  \r\n2.  ", "<", "button", " ", "catchtap", "=", "\"noWork\"", ">", "明天不上班", "</", "button", ">", "  //阻止事件冒泡  \r\n\r\n复制代码", "六、数据双向绑定", "1.设置值", "在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。", "1", ".  <div id=", "\"app\"", ">  \r\n", "2", ".  <", "input", " v-model=", "\"reason\"", " placeholder=", "\"填写理由\"", " class=", "'reason'", "/>  \r\n", "3", ".  </div>  \r\n\r\n", "5", ".  ", "new", " Vue({  \r\n", "6", ".  ", "e", "l:", " ", "'#app'", ",  \r\n", "7", ".  dat", "a:", " {  \r\n", "8", ".  reason:", "''", "  \r\n", "9", ".  }  \r\n", "10", ".  })  \r\n\r\n复制代码", "但是在小程序中，却没有这个功能。那怎么办呢？", "当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。", "下面是代码，可以感受一下:", "1", ".  <input bindinput=", "\"bindReason\"", " placeholder=", "\"填写理由\"", " class=", "'reason'", " ", "value", "=", "'{{reason}}'", " name=", "\"reason\"", " />  \r\n", "2", ".  Page({  \r\n", "3", ".  data:{  \r\n", "4", ".  reason:", "''", "  \r\n", "5", ".  },  \r\n", "6", ".  bindReason(e) {  \r\n", "7", ".  this.setData({  \r\n", "8", ".  reason: e.detail.value  \r\n", "9", ".  })  \r\n", "10", ".  }  \r\n", "11", ".  }) \r\n\r\n复制代码", "当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。", "2.取值", "vue中，通过this.reason取值", "小程序中，通过this.data.reason取值", "七、绑定事件传参", "在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：", "1.  ", "<", "button", " @", "click", "=", "\"say('明天不上班')\"", ">", "</", "button", ">", "  \r\n", "2.  ", "new Vue({  \r\n", "3.  ", "el: '#app',  \r\n", "4.  ", "methods:{  \r\n", "5.  ", "say(arg){  \r\n", "6.  ", "consloe.log(arg)  \r\n", "7.  ", "}  \r\n", "8.  ", "}  \r\n", "9.  ", "})  \r\n\r\n复制代码", "在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有...", "1.  ", "<", "view", " ", "class", "=", "'tr'", " ", "bindtap", "=", "'toApprove'", " ", "data-id", "=", "\"{{item.id}}\"", ">", "</", "view", ">", "  \r\n", "2.  ", "Page({  \r\n", "3.  ", "data:{  \r\n", "4.  ", "reason:''  \r\n", "5.  ", "},  \r\n", "6.  ", "toApprove(e) {  \r\n", "7.  ", "let id = e.currentTarget.dataset.id;  \r\n", "8.  ", "}  \r\n", "9.  ", "})  \r\n\r\n复制代码", "八、父子组件通信", "1.子组件的使用", "在vue中，需要：", "编写子组件", "在需要使用的父组件中通过import引入", "在vue的components中注册", "在模板中使用", "1.  //子组件 bar.vue  \r\n2.  ", "<", "template", ">", "  \r\n3.  ", "<", "div", " ", "class", "=", "\"search-box\"", ">", "  \r\n4.  ", "<", "div", " @", "click", "=", "\"say\"", " ", ":title", "=", "\"title\"", " ", "class", "=", "\"icon-dismiss\"", ">", "</", "div", ">", "  \r\n5.  ", "</", "div", ">", "  \r\n6.  ", "</", "template", ">", "  \r\n7.  ", "<", "script", ">", "  \r\n", "8.", "  ", "export", " ", "default", "{  \r\n", "9.", "  props:{  \r\n", "10.", "  title:{  \r\n", "11.", "  type:", "String", ",  \r\n", "12.", "  ", "default", ":", "''", "  \r\n", "13.", "  }  \r\n", "14.", "  }  \r\n", "15.", "  }, \r\n\r\n", "17.", "  methods:{  \r\n", "18.", "  say(){ \r\n", "19.", "  ", "console", ".log(", "'明天不上班'", ");  \r\n", "20.", "  ", "this", ".$emit(", "'helloWorld'", ")  \r\n", "21.", "  }  \r\n", "22.", "  } \r\n", "23.", "  ", "</", "script", ">", "  \r\n\r\n25.  // 父组件 foo.vue  \r\n26.  ", "<", "template", ">", "  \r\n27.  ", "<", "div", " ", "class", "=", "\"container\"", ">", "  \r\n28.  ", "<", "bar", " ", ":title", "=", "\"title\"", " @", "helloWorld", "=", "\"helloWorld\"", ">", "</", "bar", ">", "  \r\n29.  ", "</", "div", ">", "  \r\n30.  ", "</", "template", ">", "  \r\n\r\n32.  ", "<", "script", ">", "  \r\n", "33.", "  ", "import", " Bar ", "from", " ", "'./bar.vue'", "  \r\n", "34.", "  ", "export", " ", "default", "{  \r\n", "35.", "  data:{  \r\n", "36.", "  title:", "\"我是标题\"", "  \r\n", "37.", "  },  \r\n", "38.", "  methods:{  \r\n", "39.", "  helloWorld(){  \r\n", "40.", "  ", "console", ".log(", "'我接收到子组件传递的事件了'", ")  \r\n", "41.", "  }  \r\n", "42.", "  },  \r\n", "43.", "  components:{ \r\n", "44.", "  Bar  \r\n", "45.", "  }  \r\n", "46.", "  ", "</", "script", ">", "  \r\n\r\n复制代码", "在小程序中，需要：", "1.编写子组件", "2. 在子组件的json文件中，将该文件声明为组件", "1.  ", "{  \r\n", "2.  ", "\"component\": true  \r\n", "3.  ", "}  \r\n\r\n复制代码", "3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径", "1", ".  ", "\"usingComponents\"", ": {  \r\n", "2", ".  ", "\"tab-bar\"", ": ", "\"../../components/tabBar/tabBar\"", "  \r\n", "3", ".  }  \r\n\r\n复制代码", "4.在父组件中，直接引入即可", "1.  ", "<", "tab-bar", " ", "currentpage", "=", "\"index\"", ">", "</", "tab-bar", ">", " \r\n\r\n复制代码", "具体代码:", "1.  // 子组件  \r\n2.  ", "<!--components/tabBar/tabBar.wxml-->", "  \r\n3.  ", "<", "view", " ", "class", "=", "'tabbar-wrapper'", ">", "  \r\n4.  ", "<", "view", " ", "class", "=", "'left-bar ", "{{currentpage===\"index\"?\"active\":\"\"}", "}'", " ", "bindtap", "=", "'jumpToIndex'", ">", "  \r\n5.  ", "<", "text", " ", "class", "=", "'iconfont icon-shouye'", ">", "</", "text", ">", "  \r\n6.  ", "<", "view", ">", "首页", "</", "view", ">", "  \r\n7.  ", "</", "view", ">", "  \r\n8.  ", "<", "view", " ", "class", "=", "'right-bar ", "{{currentpage===\"setting\"?\"active\":\"\"}", "}'", " ", "bindtap", "=", "'jumpToSetting'", ">", "  \r\n9.  ", "<", "text", " ", "class", "=", "'iconfont icon-shezhi'", ">", "</", "text", ">", "  \r\n10.  ", "<", "view", ">", "设置", "</", "view", ">", "  \r\n11.  ", "</", "view", ">", "  \r\n12.  ", "</", "view", ">", "  \r\n\r\n复制代码", "2.父子组件间通信", "在vue中", "父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例:", "1.  // 父组件 foo.vue  \r\n2.  ", "<", "template", ">", "  \r\n3.  ", "<", "div", " ", "class", "=", "\"container\"", ">", "  \r\n4.  ", "<", "bar", " ", ":title", "=", "\"title\"", ">", "</", "bar", ">", "  \r\n5.  ", "</", "div", ">", "  \r\n6.  ", "</", "template", ">", "  \r\n7.  ", "<", "script", ">", "  \r\n", "8.", "  ", "import", " Bar ", "from", " ", "'./bar.vue'", "  \r\n", "9.", "  ", "export", " ", "default", "{  \r\n", "10.", "  data:{  \r\n", "11.", "  title:", "\"我是标题\"", "  \r\n", "12.", "  },  \r\n", "13.", "  components:{  \r\n", "14.", "  Bar  \r\n", "15.", "  }  \r\n", "16.", "  ", "</", "script", ">", "  \r\n\r\n18.  // 子组件bar.vue  \r\n19.  ", "<", "template", ">", "  \r\n20.  ", "<", "div", " ", "class", "=", "\"search-box\"", ">", "  \r\n21.  ", "<", "div", " ", ":title", "=", "\"title\"", " >", "</", "div", ">", "  \r\n22.  ", "</", "div", ">", "  \r\n23.  ", "</", "template", ">", "  \r\n24.  ", "<", "script", ">", "  \r\n", "25.", "  ", "export", " ", "default", "{  \r\n", "26.", "  props:{  \r\n", "27.", "  title:{  \r\n", "28.", "  type:", "String", ",  \r\n", "29.", "  ", "default", ":", "''", "  \r\n", "30.", "  }  \r\n", "31.", "  }  \r\n", "32.", "  }  \r\n", "33.", "  ", "</", "script", ">", "  \r\n\r\n复制代码", "子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。", "在小程序中", "父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：", "1.  ", "<", "tab-bar", " ", "currentpage", "=", "\"index\"", ">", "</", "tab-bar", ">", " \r\n\r\n复制代码", "此处， “index”就是要向子组件传递的值", "在子组件properties中，接收传递的值", "1.", "  ", "properties:", " {  \r\n", "2.", "  ", "// 弹窗标题  ", "\r\n", "3.", "  ", "currentpage:", " {            ", "// 属性名  ", "\r\n", "4.", "  ", "type:", " String,     ", "// 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）  ", "\r\n", "5.", "  ", "value:", " ", "'index'", "     ", "// 属性初始值（可选），如果未指定则会根据类型选择一个 ", "\r\n", "6.", "  } \r\n", "7.", "  }  \r\n复制代码", "子组件向父组件通信和vue也很类似，代码如下:", "1.", "  ", "//子组件中  ", "\r\n", "2.", "  methods: {     \r\n", "3.", "  ", "// 传递给父组件  ", "\r\n", "4.", "  cancelBut: ", "function", " (", "e", ") ", "{  \r\n", "5.", "  ", "var", " that = ", "this", ";  \r\n", "6.", "  ", "var", " myEventDetail = { ", "pickerShow", ": ", "false", ", ", "type", ": ", "'cancel'", " } ", "// detail对象，提供给事件监听函数  ", "\r\n", "7.", "  ", "this", ".triggerEvent(", "'myevent'", ", myEventDetail) ", "//myevent自定义名称事件，父组件中使用  ", "\r\n", "8.", "  }, \r\n", "9.", "  }  \r\n", "10.", "  ", "//父组件中  ", "\r\n", "11.", "  <bar bind:myevent=", "\"toggleToast\"", ">", "</", "bar", ">", "   \r\n", "12.", "  ", "// 获取子组件信息  ", "\r\n", "13.", "  toggleToast(e){  \r\n", "14.", "  ", "console", ".log(e.detail)  \r\n", "15.", "  }  \r\n\r\n复制代码", "如果父组件想要调用子组件的方法", "vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：", "1.", "  ", "//子组件  ", "\r\n", "2.", "  <bar ref=", "\"bar\"", ">", "</", "bar", ">", "  \r\n", "3.", "  ", "//父组件  ", "\r\n", "4.", "  ", "this", ".$ref.bar.子组件的方法  \r\n复制代码", "小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：", "1.", "  ", "//子组件  ", "\r\n", "2.", "  <bar id=", "\"bar\"", ">", "</", "bar", ">", "  \r\n", "3.", "  ", "// 父组件  ", "\r\n", "4.", "  ", "this", ".selectComponent(", "'#id'", ").syaHello()  \r\n\r\n复制代码", "小程序和vue在这点上太相似了，有木有。。。", "九、废话", "还有好多地方没写，之后再慢慢加上、精简。感觉自己写的有点冗余，大佬勿喷！！！", "原来地址： https://segmentfault.com/a/1190000015684864", " "]}
{"title": "mpvue 初体验之改写车标速查小程序", "author": "Rolan", "pub_time": "2018-8-8 00:15", "content": [" \n                     \n                    ", "前文", " 说到我开发了一个简单的", "小程序", "叫做 车标速查（代码以及二维码详见 ", "这里", "），本文简单讲讲如何将这个小程序转为 mpvue 开发（最终 ", "成果", " ）", "mpvue 官网的 ", "文档", " 真的是非常简单，不，应该说是简洁，因为依托 Vue，所以很多语法不需要赘述，直接去看 Vue 的文档就好了。mpvue 这个名字真的是不忍吐槽，起名也太不上心了吧 ... 反正我个人觉得不好听", "mpvue 的入门非常简单，可以看这个 ", "quickstart", "。生成的模版目录结构和 Vue 开发很像，但是有区别，为了使之构建出符合小程序项目结构的代码格式： json/wxml/wxss/js 文件。src 是开发目录，dist 是最后 build 的目录，也就是小程序的代码", "简单看一下 src 的代码结构：", "复制代码", "├── ", "App", ".vue", "\r\n├── ", "data", "\r\n│   └── ", "data", ".js", "\r\n├── ", "main", ".js", "\r\n├── ", "pages", "\r\n│   ├── ", "about", "\r\n│   │   ├── ", "index", ".vue", "\r\n│   │   └── ", "main", ".js", "\r\n│   ├── ", "detail", "\r\n│   │   ├── ", "index", ".vue", "\r\n│   │   └── ", "main", ".js", "\r\n│   └── ", "index", "\r\n│       ├── ", "index", ".vue", "\r\n│       └── ", "main", ".js", "\r\n└── ", "utils", "\r\n    └── ", "index", ".js", "App.vue 最后会被编译成 app.js/app.wxss，一些全局相关的样式和钩子函数会被放在这里（比如说 onLaunch，但是在 mpvue 里我们可以用 created 代替）。main.js 会被编译成 app.json，一些全局相关的配置放在这里（比如页面入口，tabbars 等）", "pages 目录即为每个页面，以 index 目录为例，index.vue 会被编译成 main.js/main.wxml/main.wxss，而 main.js 可以放置针对单个页面的配置，最后会被编译成 main.json（如果没有填入配置项，则不会生成该文件）", "然后来简单过下开发过程中踩的一些坑：", "pages 目录下新增入口，需要重新 ", "npm start", " 启动，因为新建了 webpack 的 entry", "关于 navigator。index 页面点击图标需要去详情页，这就有了导航需求。小程序有原生的 navigator 组件，现在用 mpvue 开发，那么能不能用 Vue-Router 呢？答案是并不可以，参考 ", "这个", " faq。所以最后还是用了小程序原生的 navigator 组件", "detail 页面的 onLoad 钩子会有一个 options 参数，如果在这个页面用 created，是获取不到的，可以看下 mpvue 的 ", "生命周期", "。因为 mpvue 不建议使用小程序的生命周期钩子，所以比较好的方式是在 mounted 的时候用 ", "this.$root.$mp.query", " 去获取 options", ".vue 文件需要加上 style／script 标签后才能被正确编译，这点不难理解，script 里的内容被编译成 js 文件，而 style 里的内容被编译成 wxss 文件，一个小程序的页面需要它们支撑", "filters 还是不能用", "关于富文本。看了下 v-html 指令是可以用的，但是是被编译成 rich-text 组件，并不符合我的要求，最后用的是 ", "mpvue-wxParse", "，还是不错的，跟 wxParse 功能基本一样", "关于 scroll-view。因为有个侧边导航点击跳转的功能，还是用了 scroll-view 去实现，并没有更好的办法", "{{}} 中小程序原生不支持的语法，mpvue 同样无法支持，比如一些复杂的计算，比如函数等", "所有页面里面的 created 生命周期函数都会在小程序加载的时候， 一次性执行，而不是每进入一个页面执行一次（可以用 mounted 或者 onLoad 或者 onReady 代替）", "总的来说，我从入门 mpvue 到用其改写这个小程序，也就不过一天时间，由此可见 mpvue 上手真的非常快，但是它给我的总体感觉是有点鸡肋，", "一方面可能是我这个项目有点简单", "（不需要用到 Vuex 以及组件化），另一方面可能还不是很了解 mpvue", "官网概括的它的主要能力：", "彻底的组件化开发能力：提高代码复用性", "完整的 Vue.js 开发体验", "方便的 Vuex 数据管理方案：方便构建复杂应用", "快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload", "支持使用 npm 外部依赖", "使用 Vue.js 命令行工具 vue-cli 快速初始化项目", "H5 代码转换编译成小程序目标代码的能力", "我觉得目前主要的亮点在于 Vuex 的可引入以及组件化开发，但是越来越觉得随着原生小程序开发的改善，这些功能都会被补充进去。所以，最大的卖点可能还是在于 ", "多端统一", "我觉得有点鸡肋的另一个重要原因是，", "使用 mpvue 开发并不能完全忽略小程序的 API 或者组件", "，比如这个小程序，还是要用 navigator 组件以及 scroll-view 组件去实现一些功能（当然随着 mpvue 生态的发展，完全有可能出现 navigator／scroll-view 的 mpvue 组件，但是这样造轮子是否值得？），而且可能还有其他一些 API。而类比 jQuery 和 js，jQuery 完全不用去考虑原生的 dom 操作方式，从而更加 “傻瓜式”。mpvue 的开发模式注定不会是这样的结局（因为并不是从小程序底层去开发）", "另外一点，用 mpvue 开发，增加了一层 vue->小程序 编译环节，所以 reload 的速度应该会比原生开发慢一点", "鲁小夫 在 ", "如何看待美团开源的 mpvue ?", " 这个问题下的答案非常值得思考：", "不过我们也该思考一下，为什么大家对微信小程序自带的机制有这么多意见，为什么大家对 vue 这么认同，为什么多端兼容这个事情这么重要，为什么微信小程序没有拥抱开源，为什么微信小程序的技术栈没能做到标准化通用化。为了兼容微信小程序，前端工程师做了这么多工作，弄了那么多框架，到底得到的是什么。", "以前看到过一句话，大概意思是，微信小程序有太多满分的开源框架可以借鉴，最后却造了个负分的轮子。", "all in all，我的看法是，如果你刚好熟悉 Vue 或者需要多端统一开发，那么 mpvue 或许是个选择，如果你只是从头开始开发一个小程序，原生开发也未尝不可。说到底，一系列小程序框架的出现无非是原生开发体验太差，但是我相信，以微信的能力，假以时日能够把小程序原生开发的体验做好。", "可能是史上最详细的 underscore 源码剖析：", "https://github.com/hanzichi/underscore-analysis", "程序员都应该学点算法：", "https://github.com/hanzichi/leetcode", "了解博主韩子迟：", "http://www.cnblogs.com/zichi/p/about.html", "GitHub：", "https://github.com/hanzichi", " Follow 楼主给楼主更多写作的动力~", " "]}
{"title": "微信小程序iOS端如何暂停animated动画", "author": "Rolan", "pub_time": "2018-8-2 00:03", "content": [" \n                     \n                    ", "在知道有 ", "animation-play-state", " 这个animation的参数时，我内心是激动的。在得知iOS端并不支持时，一股凉意袭来", "animation-play-state", "先来介绍一下今天的主角 ", "animation-play-state", "animation-play-stateCSS属性定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。", "恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。", "在MDN文档中了解到，这是一个实验中的功能，但是其作用还是强大的。既可以控制/获取元素的动画状态（paused，running）", "所以，这个animation的参数用来控制动画的播放状态再合适不过了。画外音：你还没考虑兼容性呢！对！就是这个兼容性问题。在chrome上这个参数是可以支持的，但是iOS设备上就不支持了...叹息。", "在iOS上的处理", "当然不能因为兼容性问题就不用这个参数了，当然不能让每个iOS用户去下载一个chrome浏览器，当然...", "那我们怎么解决呢？？？用JS", "通过 ", "Window.getComputedStyle()", " 方法，我们可以获取元素实时的 ", "style", " 的 ", "CSSStyleDeclaration", " 对象，这个对象表示CSS属性键值对的集合。也就是说我们使用这个方法可以获取一个正在进行动画的元素当前的 ", "style", " 值。", "PS:关于 ", "Window.getComputedStyle()", " 方法的值可以在MDN上了解到，这里不展开叙述。给出一个语法的例子（摘自MDN）", "let", " style = ", "window", ".getComputedStyle(", "element", ", [pseudoElt]);\r\n复制代码", "那么具体要怎么做呢？", "实现", "See the Penanimation-play-state by luogao (@luogao) onCodePen.", "代码已经在上面的codepen预览中展示啦，如果现实不来请点这里:point_right:Roy Luo's codepen", "大致解释一下就是：", "在元素的外层的包裹元素上添加获取到的执行动画的元素的 ", "style", " 计算属性，从而让执行动画的元素暂停下来。", "那么在微信", "小程序", "中又是如何呢？", "其实，最先遇到这个问题是在做小程序的时候。一个播放器的界面，中间一张专辑图片。在圆形的黑胶唱片边框中旋转。当播放停止，图片也同时停止旋转。 ", "停在当前旋转的位置", "当时看似简单的一个需求，使用了 ", "animation-play-state", " 并且与预期一样达到了效果， ", "在模拟器中", " 。", "没错，洋洋得意的以为完成了需求，结果真机（iOS）上一测试，原形毕露。", "当时看到小程序的官方社区中提到说iOS不支持这个 ", "animation-play-state", " ‍♂️ ‍♂️ ‍♂️ ‍", "幸得残阳映枫红在sf的一个问题中的回答让我找到了方向。感谢之～", " "]}
{"title": "JS实现监控微信小程序", "author": "Rolan", "pub_time": "2018-6-19 00:05", "content": [" \n                     \n                    ", "《使用模块化工具打包自己开发的JS库》", " 文章中有提到，当时需要写一个SDK，监控", "小程序", "的后台接口调用和页面报错，今天就来说下实现原理吧！", "原理", "之前也做过浏览器web端的SDK数据埋点上报，其实原理大同小异：通过劫持原始方法，获取需要上报的数据，最后再执行原始方法，这样就能实现无痕埋点。", "举个例子：我希望监控所有web页面的ajax请求，每次发送ajax，都需要在控制台打印出发送的url", "平时我们开发，发送ajax一般用的都是封装好的库，例如jQuery,Axios等，然而这些库，底层仍然用的是浏览器原生的XMLHttpRequest对象，因此，我们只需要修改XMLHttpRequest对象即可", "注意：由于JS的灵活性，修改原生方法是一件很容易的事，然而并不鼓励这样做！", "// 把这段代码放在所有JS代码之前，我们就实现了拦截ajax的需求", "\r\n", "window", ".XMLHttpRequest.prototype.open = (", "function", "(", "originOpen", ") ", "{\r\n    ", "return", " ", "function", "(", "method, url, async", ") ", "{\r\n        \r\n        ", "console", ".log(", "'发送了ajax，url是: '", ", url);\r\n\r\n        ", "return", " originOpen.apply(", "this", ", ", "arguments", ");\r\n    };\r\n})(", "window", ".XMLHttpRequest.prototype.open);", "在这个立即执行函数中，我们把原生的 ", "open", " 方法通过 ", "originOpen", " 暂时存储起来，然后在外面包裹一层函数，实现了打印输出url的功能，最后通过 ", "originOpen.apply", " 让原生方法运行，这样就实现了无痕拦截。", "监控小程序", "拦截wx.request", "小程序的运行环境并没有 ", "window", " 和 ", "document", " 对象，它只暴露了一个 ", "wx", " 全局对象，发送网络请求则是通过wx.request这个api，因此，这次我们需要拦截的就是 ", "wx.request", " 方法", "我们试着更改一下 ", "wx.request", "wx.request = ", "function", "(", ") ", "{\r\n    ", "console", ".log(", "'66666'", ");\r\n}", "这时控制台会报错 ", "TypeError: Cannot set property request of #<Object> which has only a getter", "这是因为， ", "wx.request", " 这个属性，只有 ", "get", " 方法而没有 ", "set", " 方法，我们可以通过 ", "Object.getOwnPropertyDescriptor", " 验证：", "const", " des = ", "Object", ".getOwnPropertyDescriptor(wx, ", "'request'", ");\r\n\r\n", "//  des {", "\r\n", "//   configurable: true,", "\r\n", "//   enumerable: true,", "\r\n", "//   get: f(),", "\r\n", "//   set: undefined", "\r\n", "// }", "我们可以换种方式修改：", "const", " originRequest = wx.request;\r\n", "Object", ".defineProperty(wx, ", "'request'", ", {\r\n    ", "configurable", ": ", "true", ",\r\n    ", "enumerable", ": ", "true", ",\r\n    ", "writable", ": ", "true", ",\r\n    ", "value", ": ", "function", "(", ") ", "{\r\n        ", "const", " config = ", "arguments", "[", "0", "] || {};\r\n        ", "const", " url = config.url;\r\n        ", "console", ".log(", "'发送了ajax，url是: '", ", url);\r\n\r\n        ", "return", " originRequest.apply(", "this", ", ", "arguments", ");\r\n    }\r\n});", "这次就实现拦截功能了！", "监控异常", "小程序的注册函数 ", "App", " 有个全局的 ", "onError", " 方法，我们可以在小程序的入口文件 ", "app.js", " 先注册一个该方法:", "App", "({\r\n    ", "onError", ": function(err) {\r\n        console.log(", "'上报错误啦！'", ");\r\n        ", "wx", ".request", "({\r\n            ", "url", ": ", "'http://monitor.com/monitor/error'", ",\r\n            ", "data", ": err\r\n        })\r\n    }\r\n})\r\n\r\n", "App", "({\r\n    ", "// 其他逻辑", "\r\n})", "不过需要注意的是：如果后续的程序重写了onError的话，将会导致之前注册的onError失效。", "解决方法可以是：我们监控SDK可以暴露一个接口，让接入方自己在onError中调用我们的接口。", "App", "({\r\n  ", "onError", ": function (err) {\r\n    monitor.", "notifyError", "(err)\r\n  }\r\n})", "上报数据", "收集好需要的数据后，当然就要上报后台。怎么上报？当然还是用的 ", "wx.request", " 发送请求。", "这里就容易出现一个 ", "死循环", " : 如果用之前被我们包装过的 ", "wx.request", " 上报数据，那么上报数据这个ajax请求，也会被我们认为是普通的ajax请求，然后又会触发上报，这样来来回回，无穷无尽的发送上报数据。", "解决方法有多种，比如：", "方案1", "可以在包装 ", "wx.request", " 的时候，判断发送的url如果是上报接口，那么就不再上报了。", "const", " originRequest = wx.request;\r\n", "Object", ".defineProperty(wx, ", "'request'", ", {\r\n    ", "configurable", ": ", "true", ",\r\n    ", "enumerable", ": ", "true", ",\r\n    ", "writable", ": ", "true", ",\r\n    ", "value", ": ", "function", "(", ") ", "{\r\n        ", "const", " config = ", "arguments", "[", "0", "] || {};\r\n        ", "const", " url = config.url;\r\n        ", "if", " (url.indexOf(", "'http://monitor.com'", ") > ", "-1", ") {\r\n            ", "// 直接发送请求，不上报", "\r\n            ", "return", " originRequest.apply(", "this", ", ", "arguments", ");\r\n        }\r\n\r\n        ", "console", ".log(", "'上报ajax数据啦!'", ");\r\n        wx.request({\r\n            ", "url", ": ", "'http://monitor.com/monitor/ajax'", ",\r\n            ", "data", ": config.data\r\n        })\r\n\r\n        ", "return", " originRequest.apply(", "this", ", ", "arguments", ");\r\n    }\r\n});", "方案2", "在包装 ", "wx.request", " 之前，保留一份最原始的 ", "wx.request", " 方法，所有的上报请求，就不走被包装过的方法，而走最原始的方法。", "const", " myRequest = wx.request;\r\n\r\n", "const", " wrapRequest = ", "function", " (", ") ", "{\r\n    ", "const", " originRequest = wx.request;\r\n    ", "Object", ".defineProperty(wx, ", "'request'", ", {\r\n        ", "configurable", ": ", "true", ",\r\n        ", "enumerable", ": ", "true", ",\r\n        ", "writable", ": ", "true", ",\r\n        ", "value", ": ", "function", "(", ") ", "{\r\n            ", "const", " config = ", "arguments", "[", "0", "] || {};\r\n            ", "const", " url = config.url;\r\n       \r\n            ", "console", ".log(", "'上报数据啦!'", ");\r\n            ", "// 使用最原始的request方法", "\r\n            myRequest({\r\n                ", "url", ": ", "'http://monitor.com/monitor/ajax'", ",\r\n                ", "data", ": config.data\r\n            })\r\n\r\n            ", "return", " originRequest.apply(", "this", ", ", "arguments", ");\r\n        }\r\n    });\r\n}\r\n\r\nwrapRequest();", "其他事项", "实际开发中当然还有更多的细节，比如监控项目的鉴权，SDK的代码结构，上报前的数据收集和聚合等等，本文就不详细展开了。", " "]}
{"title": "微信小程序开发教程第五章：名片夹详情页开发", "author": "admin", "pub_time": "2016-10-12 22:39", "content": [" \n                     \n                    ", "先看下「名片盒」详情页的效果图：", "备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。", "首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。", "Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。", "noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。", "Block：图片列表。", "Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。", "其中 currentNumber：", "//轮播图发生改变时改变数字", "//初始化数据", "Data:{", "currentNumber:1", "}", "slidechange:function(e){", "var number = e.detail.current;", "this.setData({", "currentNumber:number+1", "})", "},", "这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。", "再次点击返回原样式，", "切换后事件又走回到 getBackStyle 了，灵活运用。", "刷新下开发者工具可以看到具体效果如下：", "详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。", "下面是详情页里面的个人信息数据，", "如果有信息就显示出来，没有数据的不显示，这里使用", "//中文信息", "               var chinaMessage = res.card.groups[0].fields;", "var personMessage= []", "               for(var i = 0;i", "                personMessage.push(chinaMessage[i])", "               }", "               //为空或者null是不显示判断", "              for(var k in personMessage){", "                if(personMessage[k].value==null || personMessage[k].value==\"\"){", "                personMessage[k][\"display\"] = \"none\";", "                }else{", "                personMessage[k][\"display\"] = \"block\";", "                }", "               }", "具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。", "微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。", "这里说明下：如是服务器真实数据。", "可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。", "定义一个变量即可。", "当然这里的数据都是 push 上来的。", "以下是二维码弹出信息。", "这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：", "This.setData({", "//模态框名字:”显示？隐藏”", "})", "方法是让它显示。", "需要用他的地方调用方法即可。(支持重复调用)", "详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。", "可以看下实现的效果：", " "]}
{"title": "【小程序】微信小程序绑定企业微信后怎样获取到用户信息", "author": "Rolan", "pub_time": "2018-6-26 00:42", "content": [" \n                     \n                    ", "一、", "获取", "access_token", "1", "、", "https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&corpsecret=SECRECT", "Corpid", "和", "secrect", "是唯一的", " access_token:有效期2小时", "二、", "获取", "code", "小程序", "调用", "wx.login", "获取临时登录凭证", "code", "，并回传到开发者服务器", " ", "三、", "获取用户", "id", "https://qyapi.weixin.qq.com/cgi-bin/miniprogram/jscode2session?access_token=ACCESS_TOKEN&js_code=CODE&grant_type=authorization_code", "返回结果", " "]}
{"title": "微信小程序 CSS 选择器::after和::before的简单使用", "author": "Rolan", "pub_time": "2018-7-5 00:39", "content": [" \n                     \n                    ", "前言", "前两天看文档看到选择器那块儿的时候，前面4个基本都能理解：.class，#id，element，element, element，但后面两个::after和::before（文档中说，分别表示在view 组件的后面和前面插入内容），表示有点没有理解。于是上网仔细查了下。以下是笔记", "image", "基本概念", "::before 用法：view::before，表示在该view组件的前面加入内容 ", "::after 用法：view::after，表示在该view组件的后面加入内容 ", "这里是双冒号，不是单冒号。单冒号是CSS2的内容，双冒号是CSS3的内容。当然微信", "小程序", "也是兼容CSS2的写法的 ", "这种在组件的前面和后面加入内容，其实有点类似Android中的给TextView四周加图片的做法，setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)（原谅我这里有点强行建立联系的奇怪思路）", "用法", "wxml", "<view", " ", "class", "=", "\"container\"", ">", "    ", "<view", " ", "class", "=", "\"price\"", ">", "{{price}}", "</view>", "</view>", "wxss", ".", "container ", "{", "  width", ":", " ", "auto", ";", "  margin", ":", " ", "30rpx", ";", "  background", "-", "color", ":", " ", "#fff;", "  text", "-", "align", ":", " center", ";", "}", ".", "price ", "{", "  position", ":", " relative", ";", "  display", ":", " ", "inline", "-", "block", ";", "  font", "-", "size", ":", " ", "78rpx", ";", "  color", ":", " red", ";", "}", ".", "price", "::", "before ", "{", "  content", ":", " ", "\"金额：¥\"", ";", "  position", ":", " absolute", ";", "  font", "-", "size", ":", " ", "40rpx", ";", "  top", ":", " ", "30rpx", ";", "  left", ":", " ", "-", "160rpx", ";", "  color", ":", " black", ";", "}", ".", "price", "::", "after ", "{", "  content", ":", " ", "\".00 元\"", ";", "  font", "-", "size", ":", " ", "30rpx", ";", "  top", ":", " ", "40rpx", ";", "  position", ":", " absolute", ";", "  right", ":", " ", "-", "90rpx", ";", "  color", ":", " black", ";", "}", "js", "Page", "({", "  onLoad", ":", " ", "function", "()", " ", "{", "    ", "this", ".", "setData", "({", "      price", ":", " ", "100", "    ", "})", "  ", "}", "})", "效果", "image", "其他", "其实，after和before可以添加的不仅仅是像上面这种字符串，以下是可以添加的常用的内容", "String", " ", "静态字符串", "attr ", "动态内容", "url", "/", "uri ", "用于引用媒体文件", "counter ", "计数器，可以实现序号功能", " ", " "]}
{"title": "【微信小程序】性能优化", "author": "Rolan", "pub_time": "2018-7-17 00:38", "content": [" \n                     \n                    ", "内容整理于微信公开课", "\r\n", "为什么要做性能优化？", "\r\n", "一切性能优化都是为了体验优化", "\r\n", "1. 使用", "小程序", "时，是否会经常遇到如下问题？", "\r\n", "\r\n", "\r\n", "打开是一直白屏", "\r\n", "\r\n", "\r\n", "打开是loading态，转好几圈", "\r\n", "\r\n", "\r\n", "我的页面点了怎么跳转这么慢？", "\r\n", "\r\n", "\r\n", "我的列表怎么越滑越卡？", "\r\n", "\r\n", "\r\n", "2. 我们优化的方向有哪些？", "\r\n", "\r\n", "\r\n", "启动加载性能", "\r\n", "\r\n", "\r\n", "渲染性能", "\r\n", "\r\n", "\r\n", "3. 启动加载性能", "\r\n", "1. 首次加载", "\r\n", "你是否见过小程序首次加载时是这样的图？", "\r\n", "\r\n", "这张图中的三种状态对应的都是什么呢？", "\r\n", "小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：", "下载小程序代码包", "、", "加载小程序代码包", "、", "初始化小程序首页", "。下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包。", "\r\n", "2. 加载顺序", "\r\n", "小程序加载的顺序是如何？", "\r\n", "微信会在小程序启动前为小程序准备好通用的运行环境。这个运行环境包括几个供小程序使用的线程，并在其中完成小程序基础库的初始化，预先执行通用逻辑，尽可能做好小程序的启动准备。这样可以显著减少小程序的启动时间。", "\r\n", "\r\n通过2，我们知道了，问题1中第一张图是", "资源准备", "（代码包下载）；第二张图是", "业务代码的注入以及落地页首次渲染", "；第三张图是", "落地页数据请求时的loading态", "（部分小程序存在）", "\r\n", "3. 控制包大小", "\r\n", "提升体验最直接的方法是控制小程序包的大小，这是最显而易见的", "\r\n", "\r\n", "\r\n", "勾选开发者工具中“上传代码时，压缩代码”选项；", "\r\n", "\r\n", "\r\n", "及时清理无用的代码和资源文件（包括无用的日志代码）", "\r\n", "\r\n", "\r\n", "减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限", "\r\n", "\r\n", "\r\n", "从开发者的角度看，控制代码包大小有助于减少小程序的启动时间。", "对低于1MB的代码包，其下载时间可以控制在929ms（iOS）、1500ms（Android）内", "。", "\r\n", "4. 采用分包加载机制", "\r\n", "根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；", "\r\n", "\r\n使用分包时需要注意代码和资源文件目录的划分。启动时需要访问的页面及其依赖的资源文件应放在主包中。", "\r\n", "5 采用分包预加载技术", "\r\n", "在4的基础上，当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包，而是可以根据后期数据，做子包预加载，将用户在当先页可能点击的子包页面先加载，当用户点击后直接跳转；", "\r\n", "\r\n这种基于配置的子包预加载技术，是可以根据用户网络类型来判断的，当用户处于网络条件好时才预加载；是灵活可控的", "\r\n", "6. 采用独立分包技术", "\r\n", "目前很多小程序", "主包+子包", "（2M+6M）的方式，但是在做很多运营活动时，我们会发现活动（红包）是在子包里，但是运营、产品投放的落地页链接是子包链接，这是的用户在直达落地时，必须先下载主包内容（一般比较大），在下载子包内容（相对主包，较小），这使得在用户停留时间比较短的小程序场景中，用户体验不是很好，而且浪费了很大部分流量；", "\r\n", "\r\n可以采用独立分包技术，区别于子包，和主包之间是无关的，在功能比较独立的子包里，使用户只需下载分包资源；", "\r\n", "7. 首屏加载的优化建议", "\r\n", "7.1 提前请求", "\r\n", "异步请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；当然，如果能在前置页面点击跳转时预请求当前页的核心异步请求，效果会更好；", "\r\n", "7.2 利用缓存", "\r\n", "利用storage API, 对变动频率比较低的异步数据进行缓存，二次启动时，先利用缓存数据进行初始化渲染，然后后台进行异步数据的更新，这不仅优化了性能，在无网环境下，用户也能很顺畅的使用到关键服务；", "\r\n", "7.3 避免白屏", "\r\n", "可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位，使用户不会等待的很焦虑，甚至走了；", "\r\n", "7.4 及时反馈", "\r\n", "及时的对需要用户等待的交互操作进行反馈，避免用户以为小程序卡了，无响应", "\r\n", "\r\n", "渲染性能优化", "\r\n", "1. 小程序渲染原理", "\r\n", "双线程下的界面渲染，小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。", "\r\n", "\r\n分析这个流程不难得知：页面初始化的时间大致由页面初始数据通信时间和初始渲染时间两部分构成。其中，数据通信的时间指数据从逻辑层开始组织数据到视图层完全接收完毕的时间，", "数据量小于64KB时总时长可以控制在30ms内", "。传输时间与数据量大体上呈现正相关关系，传输过大的数据将使这一时间显著增加。因而减少传输数据量是降低数据传输时间的有效方式。", "\r\n", "\r\n", "2. 避免使用不当setData", "\r\n", "在数据传输时，逻辑层会执行一次", "JSON.stringify", "来去除掉", "setData", "数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将", "setData", "所设置的数据字段与", "data", "合并，使开发者可以用", "this.data", "读取到变更后的数据。因此，为了提升数据更新的性能，开发者在执行", "setData", "调用时，最好遵循以下原则：", "\r\n", "2.1 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；", "\r\n", "\r\n", "2.2 数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用", "setData", "来设置这些数据；", "\r\n", "\r\n", "2.3 与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下", "\r\n", "\r\n", "提升数据更新性能方式的代码示例", "\r\n", "Page({\r\n  ", "onShow", ": ", "function", "(", ") ", "{\r\n\r\n    ", "// 不要频繁调用setData", "\r\n    ", "this", ".setData({ ", "a", ": ", "1", " })\r\n    ", "this", ".setData({ ", "b", ": ", "2", " })\r\n    ", "// 绝大多数时候可优化为", "\r\n    ", "this", ".setData({ ", "a", ": ", "1", ", ", "b", ": ", "2", " })\r\n\r\n    ", "// 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外", "\r\n    ", "this", ".setData({\r\n      ", "myData", ": {\r\n        ", "a", ": ", "'这个字符串在WXML中用到了'", ",\r\n        ", "b", ": ", "'这个字符串未在WXML中用到，而且它很长…………………………'", "\r\n      }\r\n    })\r\n    ", "// 可以优化为", "\r\n    ", "this", ".setData({\r\n      ", "'myData.a'", ": ", "'这个字符串在WXML中用到了'", "\r\n    })\r\n    ", "this", "._myData = {\r\n      ", "b", ": ", "'这个字符串未在WXML中用到，而且它很长…………………………'", "\r\n    }\r\n\r\n  }\r\n})\r\n", "复制代码", "2.4 切勿在后台页面进行setData", "\r\n", "在一些页面会进行一些操作，而到页面跳转后，代码逻辑还在执行，此时多个", "webview", "是共享一个js进程；后台的", "setData", "操作会抢占前台页面的渲染资源；", "\r\n", "\r\n", "\r\n", "3. 用户事件使用不当", "\r\n", "视图层将事件反馈给逻辑层时，同样需要一个通信过程，通信的方向是从视图层到逻辑层。因为这个通信过程是异步的，会产生一定的延迟，延迟时间同样与传输的数据量正相关，", "数据量小于64KB时在30ms内", "。降低延迟时间的方法主要有两个。", "\r\n", "1.去掉不必要的事件绑定（WXML中的", "bind", "和", "catch", "），从而减少通信的数据量和次数；\r\n2.事件绑定时需要传输", "target", "和", "currentTarget", "的", "dataset", "，因而不要在节点的", "data", "前缀属性中放置过大的数据。", "\r\n", "\r\n", "4. 视图层渲染原理", "\r\n", "4.1首次渲染", "\r\n", "初始渲染发生在页面刚刚创建时。初始渲染时，将初始数据套用在对应的WXML片段上生成节点树。节点树也就是在开发者工具WXML面板中看到的页面树结构，它包含页面内所有组件节点的名称、属性值和事件回调函数等信息。最后根据节点树包含的各个节点，在界面上依次创建出各个组件。", "\r\n", "\r\n", "在这整个流程中，时间开销大体上与节点树中节点的总量成正比例关系。因而减少WXML中节点的数量可以有效降低初始渲染和重渲染的时间开销，提升渲染性能。", "\r\n", "简化WXML代码的例子", "\r\n", "<", "view", " ", "data-my-data", "=", "\"{{myData}}\"", ">", " ", "\r\n  ", "<", "view", " ", "class", "=", "\"my-class\"", " ", "data-my-data", "=", "\"{{myData}}\"", " ", "bindtap", "=", "\"onTap\"", ">", "\r\n    ", "<", "text", ">", " ", "\r\n      {{myText}}\r\n    ", "text", ">\r\n  ", "view", ">\r\n", "view", ">\r\n\r\n", "\r\n\r\n", "<", "view", " ", "class", "=", "\"my-class\"", " ", "data-my-data", "=", "\"{{myData}}\"", " ", "bindtap", "=", "\"onTap\"", ">", "\r\n  {{myText}}\r\n", "view", ">\r\n", "复制代码", "4.2 重渲染", "\r\n", "初始渲染完毕后，视图层可以多次应用", "setData", "的数据。每次应用", "setData", "数据时，都会执行重渲染来更新界面。初始渲染中得到的data和当前节点树会保留下来用于重渲染。每次重渲染时，将", "data", "和", "setData", "数据套用在WXML片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将", "setData", "数据合并到", "data", "中，并用新节点树替换旧节点树，用于下一次重渲染。", "\r\n", "\r\n", "在进行当前节点树与新节点树的比较时，会着重比较", "setData", "数据影响到的节点属性。因而，去掉不必要设置的数据、减少", "setData", "的数据量也有助于提升这一个步骤的性能。", "\r\n", "5. 使用自定义组件", "\r\n", "自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用。", "\r\n", "\r\n", "6. 避免不当的使用onPageScroll", "\r\n", "每一次事件监听都是一次视图到逻辑的通信过程，所以只在必要的时候监听pageSrcoll", "\r\n", "\r\n", "总结", "\r\n", "小程序启动加载性能", "\r\n", "\r\n", "\r\n", "控制代码包的大小", "\r\n", "\r\n", "\r\n", "分包加载", "\r\n", "\r\n", "\r\n", "首屏体验（预请求，利用缓存，避免白屏，及时反馈", "\r\n", "\r\n", "\r\n", "小程序渲染性能", "\r\n", "\r\n", "\r\n", "避免不当的使用setData", "\r\n", "\r\n", "\r\n", "合理利用事件通信", "\r\n", "\r\n", "\r\n", "避免不当的使用onPageScroll", "\r\n", "\r\n", "\r\n", "优化视图节点", "\r\n", "\r\n", "\r\n", "使用自定义组件", " "]}
{"title": "Taro实践 - TOPLIFE小程序 开发体验", "author": "Rolan", "pub_time": "2018-7-5 00:32", "content": [" \n                     \n                    ", "前阵子，来自我们凹凸实验室的遵循React 语法规范的 ", "多端开发方案", " - ", "Taro", " 终于对外开源了，欢迎围观 ", "star", " （先打波广告）。作为第一批使用了 ", "Taro", " 开发的TOPLIFE", "小程序", "的开发人员之一，自然是走了不少弯路，躺了不少坑，也帮忙找过不少bug。现在项目总算是上线了，那么，也是时候给大家总结分享下了。", "与WePY比较", "当初开发TOPLIFE第一期的时候，用的其实是 ", "WePY", " （那时Taro还没有开发完成），然后在第二期才全面转换为用 ", "Taro", " 开发。作为两个小程序开发框架都使用过，并应用在生产环境里的人，自然是要比较一下两者的异同点。", "相同点", "组件化开发", "npm包支持", "ES6+特性支持，Promise， ", "Async Functions", " 等", "CSS预编译器支持，Sass/Stylus/PostCSS等", "支持使用Redux进行状态管理", "…..", "相同的地方也不用多说什么，都2018年了，这些特性的支持都是为了让小程序开发变得更现代，更工程化，重点是区别之处。", "不同点", "开发风格", "实现原理", "WePY支持slot，Taro暂不支持直接渲染children", "开发风格", "最大的不同之处，自然就是开发风格上的差异， ", "WePY", " 使用的是类Vue开发风格， ", "Taro", " 使用的是类React 开发风格，可以说开发体验上还是会有较大的区别。贴一下官方的demo简单阐述下。", "WePY demo", "<style lang=", "\"less\"", ">\r\n    ", "@color", ": #", "4", "D926F;\r\n    .userinfo {\r\n        color: ", "@color", ";\r\n    }\r\n</style>\r\n<template lang=", "\"pug\"", ">\r\n    view(", "class", "=", "'containe", "r')\r\n        view(", "class", "=", "'userinf", "o' ", "@tap", "=", "'ta", "p')\r\n            mycom(:prop.sync=", "'mypro", "p' ", "@fn", ".user=", "'myeven", "t')\r\n            text {{now}}\r\n</template>\r\n\r\n<script>\r\n    ", "import", " wepy from ", "'wep", "y';\r\n    ", "import", " mycom from '../components/mycom';\r\n\r\n    export ", "default", " ", "class", " ", "Index", " ", "extends", " ", "wepy", ".", "page", " ", "{\r\n        \r\n        components = { mycom };\r\n        data = {\r\n            myprop: {}\r\n        };\r\n        computed = {\r\n            now () { ", "return", " ", "new", " ", "Date", "().getTime(); }\r\n        };\r\n        async onLoad() {\r\n            await sleep(", "3", ");\r\n            console.log(", "'Hello", " ", "World", "');\r\n        }\r\n        sleep(time) {\r\n            ", "return", " ", "new", " ", "Promise", "((resolve, reject) => setTimeout(resolve, time * ", "1000", "));\r\n        }\r\n    }\r\n</script>", "Taro demo", "import", " Taro, { Component } ", "from", " ", "'@tarojs/taro'", "\r\n", "import", " { View, Button } ", "from", " ", "'@tarojs/components'", "\r\n\r\n", "export", " ", "default", " ", "class", " ", "Index", " ", "extends", " ", "Component", " ", "{\r\n  ", "constructor", " () {\r\n    ", "super", "(...arguments)\r\n    ", "this", ".state = {\r\n      ", "title", ": ", "'首页'", ",\r\n      ", "list", ": [", "1", ", ", "2", ", ", "3", "]\r\n    }\r\n  }\r\n\r\n  componentWillMount () {}\r\n\r\n  componentDidMount () {}\r\n\r\n  componentWillUpdate (nextProps, nextState) {}\r\n\r\n  componentDidUpdate (prevProps, prevState) {}\r\n\r\n  shouldComponentUpdate (nextProps, nextState) {\r\n    ", "return", " ", "true", "\r\n  }\r\n\r\n  add = ", "(", "e", ") =>", " {\r\n    ", "// dosth", "\r\n  }\r\n\r\n  render () {\r\n    ", "return", " (\r\n      ", "<", "View", " ", "className", "=", "'index'", ">", "\r\n        ", "<", "View", " ", "className", "=", "'title'", ">", "{this.state.title}", "</", "View", ">", "\r\n        ", "<", "View", " ", "className", "=", "'content'", ">", "\r\n          {this.state.list.map(item => {\r\n            return (\r\n              ", "<", "View", " ", "className", "=", "'item'", ">", "{item}", "</", "View", ">", "\r\n            )\r\n          })}\r\n          ", "<", "Button", " ", "className", "=", "'add'", " ", "onClick", "=", "{this.add}", ">", "添加", "</", "Button", ">", "\r\n        ", "</", "View", ">", "\r\n      ", "</", "View", ">", "\r\n    )\r\n  }\r\n}", "可以见到在 WePY 里， ", "css", " 、 ", "template", " 、 ", "script", " 都放在一个wpy文件里， ", "template", " 还支持多种模板引擎语法，然后支持 ", "computed", " 、 ", "watcher", " 等属性，这些都是典型的Vue风格。", "而在 Taro 里，就是彻头彻尾的 React 风格，包括 ", "constructor", " ， ", "componentWillMount", " 、 ", "componentDidMount", " 等各种 React 的生命周期函数，还有 ", "return", " 里返回的 ", "jsx", " ，熟悉 React 的人上手起来可以说是非常快了。", "除此之外还有一些细微的差异之处：", "WePY 里的模板，或者说是 ", "wxml", " ，用的都是小程序里原生的组件，就是小程序文档里的各种组件；而Taro里使用的每个组件，都需要从 ", "@tarojs/components", " 里引入，包括 ", "View", " ， ", "Text", " 等基础组件（这种做其实是为了转换多端做准备）", "事件处理上", "Taro 中，是用 ", "click", " 事件代替 ", "tap", " 事件", "WePY使用的是简写的写法@+事件；而Taro则是on+事件名称", "阻止冒泡上WePY用的是@+事件.stop；而Taro则是要显式地使用 ", "e.stopPropagation()", "来阻止冒泡", "事件传参WePY可以直接在函数后面传参，如 ", "@tap=\"click({{index}})\"", " ；而Taro则是使用 ", "bind", " 传参，如 ", "onClick={this.handleClick.bind(null, params)}", "WePY使用的是小程序原生的生命周期，并且组件有 ", "page", " 和 ", "component", " 的区分；Taro 则是自己实现了类似React 的生命周期，而且没有 ", "page", " 和 ", "component", " 的区分，都是 ", "component", "总的来说，毕竟是两种不同的开发风格，自然还是会有许多大大小小的差异。在这里与当前很流行的小程序开发框架之一 ", "WePY", " 进行简单对比，主要还是为了方便大家更快速地了解 ", "Taro", " ，从而选择更适合自己的开发方式。", "实践体验", "Taro", " 官方提供的demo 是很简单的，主要是为了让大家快速上手，入门。那么，当我们要开发偏大型的项目时，应该如何使用 ", "Taro", " 使得开发体验更好，开发效率更高？作为深度参与TOPLIFE小程序开发的人员之一，谈一谈我的一些实践体验及心得", "如何组织代码", "使用taro-cli生成模板是这样的", "├── dist                   编译结果目录\r\n├── config                 配置目录\r\n", "|   ├── dev.js             开发时配置\r\n|", "   ├── index.js           默认配置\r\n", "|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|", "   ├── pages              页面文件目录\r\n", "|   |", "   ├── index          index页面目录\r\n", "|   |", "   ", "|   ├── index.js   index页面逻辑\r\n|", "   ", "|   |", "   └── index.css  index页面样式\r\n", "|   ├── app.css            项目总通用样式\r\n|", "   └── app.js             项目入口文件\r\n└── package.json", "假如引入了redux，例如我们的项目，目录是这样的", "├── dist                   编译结果目录\r\n├── config                 配置目录\r\n", "|   ├── dev.js             开发时配置\r\n|", "   ├── index.js           默认配置\r\n", "|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|", "   ├── actions            redux里的actions\r\n", "|   ├── asset              图片等静态资源\r\n|", "   ├── components         组件文件目录\r\n", "|   ├── constants          存放常量的地方，例如api、一些配置项\r\n|", "   ├── reducers           redux里的reducers\r\n", "|   ├── store              redux里的store\r\n|", "   ├── utils              存放工具类函数\r\n", "|   ├── pages              页面文件目录\r\n|", "   ", "|   ├── index          index页面目录\r\n|", "   ", "|   |", "   ├── index.js   index页面逻辑\r\n", "|   |", "   ", "|   └── index.css  index页面样式\r\n|", "   ├── app.css            项目总通用样式\r\n", "|   └── app.js             项目入口文件\r\n└── package.json", "TOPLIFE小程序整个项目大概3万行代码，数十个页面，就是按上述目录的方式组织代码的。比较重要的文件夹主要是 ", "pages", " 、 ", "components", " 和 ", "actions", " 。", "pages里面是各个页面的入口文件，简单的页面就直接一个入口文件可以了，倘若页面比较复杂那么入口文件就会作为组件的聚合文件， ", "redux", " 的绑定一般也是在这里进行。", "组件都放在 ", "components", " 里面。里面的目录是这样的，假如有个 ", "coupon", " 优惠券页面，在 ", "pages", " 自然先有个 ", "coupon", " ，作为页面入口，然后它的组件就会存放在 ", "components/coupon", " 里面，就是 ", "components", " 里面也会按照页面分模块，公共的组件可以建一个 ", "components/public", " 文件夹，进行复用。", "这样的好处是页面之间 ", "互相独立", " ， ", "互不影响", " 。所以我们几个开发人员，也是按照页面的维度来进行分工，互不干扰，大大提高了我们的开发效率。", "actions这个文件夹也是比较重要，这里处理的是拉取数据，数据再处理的逻辑。可以说，数据处理得好，流动清晰，整个项目就成功了一半，具体可以看下面***更好地使用redux***的部分。如上，假如是 ", "coupon", " 页面的 ", "actions", " ，那么就会放在 ", "actions/coupon", " 里面，可以再一次见到，所有的模块都是以页面的维度来区分的。", "除此之外， ", "asset", " 文件用来存放的静态资源，如一些icon类的图片，但建议不要存放太多，毕竟程序包有限制。而 ", "constants", " 则是一些存放常量的地方，例如 ", "api", " 域名，配置等等。", "只要按照上述或类似的代码组织方式，遵循规范和约定，开发大型项目时不说能提高多少效率，至少顺手了很多。", "更好地使用redux", "redux大家应该都不陌生，一种状态管理的库，通常会搭配一些中间件使用。我们的项目主要是用了 ", "redux-thunk", " 和 ", "redux-logger", " 中间件，一个用于处理异步请求，一个用于调试，追踪 ", "actions", " 。", "数据预处理", "相信大家都遇到过这种时候，接口返回的数据和页面显示的数据并不是完全对应的，往往需要再做一层预处理。那么这个业务逻辑应该在哪里管理，是组件内部，还是 ", "redux", " 的流程里？", "举个例子：", "例如上图的购物车模块，接口返回的数据是", "{\r\n\t", "code", ": ", "0", ",\r\n\t", "data", ": {\r\n        ", "shopMap", ": {...}, ", "// 存放购物车里商品的店铺信息的map", "\r\n        ", "goods", ": {...}, ", "// 购物车里的商品信息", "\r\n        ...\r\n\t}\r\n\t...\r\n}", "对的，购车里的商品店铺和商品是放在两个对象里面的，但视图要求它们要显示在一起。这时候，如果直接将返回的数据存到 ", "store", " ，然后在组件内部 ", "render", " 的时候东拼西凑，将两者信息匹配，再做显示的话，会显得组件内部的逻辑十分的混乱，不够纯粹。", "所以，我个人比较推荐的做法是，在接口返回数据之后，直接将其处理为与页面显示对应的数据，然后再 ", "dispatch", " 处理后的数据，相当于做了一层拦截，像下面这样：", "const", " data = result.data ", "// result为接口返回的数据", "\r\n", "const", " cartData = handleCartData(data) ", "// handleCartData为处理数据的函数", "\r\ndispatch({", "type", ": ", "'RECEIVE_CART'", ", payload: cartData}) ", "// dispatch处理过后的函数", "\r\n\r\n...\r\n", "// handleCartData处理后的数据", "\r\n{\r\n    commoditys: [{\r\n        shop: {...}, ", "// 商品店铺的信息", "\r\n        goods: {...}, ", "// 对应商品信息", "\r\n    }, ...]\r\n}", "可以见到，处理数据的流程在render前被拦截处理了，将对应的商品店铺和商品放在了一个对象了.", "这样做有几个好处", "一个是组件的渲染 ", "更纯粹", " ，在组件内部不用再关心如何将数据修修改改而满足视图要求， ", "只需关心组件本身的逻辑", " ，例如点击事件，用户交互等", "二是数据的流动 ", "更可控", " ，假如后续后台返回的数据有变动，我们要做的只是改变 ", "handleCartData", " 函数里面的逻辑，不用改动组件内部的逻辑。", "后台数据——>拦截处理——>期望的数据结构——>组件", "实际上，不只是后台数据返回的时候，其它数据结构需要变动的时候都可以做一层数据拦截，拦截的时机也可以根据业务逻辑调整，重点是要让组件内部本身不关心 ", "数据与视图是否对应，只专注于内部交互的逻辑", " ，这也很符合 ", "React", " 本身的初衷，数据驱动视图。", "connect可以做更多的事情", "connect", " 大家都知道是用来连接 ", "store", " 、 ", "actions", " 和组件的，很多时候就只是根据样板代码复制一下，改改组件各自的 ", "store", " 、 ", "actions", " 。实际上，我们还可以做一些别的处理，例如：", "export", " ", "default", " connect(({\r\n  cart,\r\n}) => ({\r\n  couponData: cart.couponData,\r\n  commoditys: cart.commoditys,\r\n  editSkuData: cart.editSkuData\r\n}), (dispatch) => ({\r\n  ", "// ...actions绑定", "\r\n}))(Cart)\r\n\r\n", "// 组件里", "\r\nrender () {\r\n\t", "const", " isShowCoupon = ", "this", ".props.couponData.length !== ", "0", "\r\n    ", "return", " isShowCoupon && <Coupon />\r\n}\r\n", "上面是很普通的一种 ", "connect", " 写法，然后 ", "render", " 函数根据 ", "couponData", " 里是否数据来渲染。这时候，我们可以把 ", "this.props.couponData.length !== 0", " 这个判断丢到 ", "connect", " 里，达成一种 ", "computed", " 的效果，如下：", "export", " ", "default", " connect(({\r\n  cart,\r\n}) => {\r\n  ", "const", " { couponData, commoditys, editSkuData  } = cart\r\n  ", "const", " isShowCoupon = couponData.length !== ", "0", "\r\n  ", "return", " {\r\n    isShowCoupon,\r\n    couponData,\r\n    commoditys,\r\n    editSkuData\r\n}}, (dispatch) => ({\r\n  ", "// ...actions绑定", "\r\n}))(Cart)\r\n\r\n", "// 组件里", "\r\nrender () {\r\n    ", "return", " ", "this", ".props.isShowCoupon && <Coupon />\r\n}\r\n", "可以见到，在 ", "connect", " 里定义了 ", "isShowCoupon", " 变量，实现了根据 ", "couponData", " 来进行 ", "computed", " 的效果。", "实际上，这也是一种数据拦截处理。除了 ", "computed", " ，还可以实现其它的功能，具体就由各位看官自由发挥了。", "项目感受", "要说最大的感受，就是在开发的过程中， ", "有时会忘记了自己在写小程序，还以为是在写React页面", " 。是的，有次我想给页面绑定一个滚动事件，才醒悟根本就没有 ", "doucment.body.addEventListener", " 这种东西。在使用 ", "WePY", " 过程中，那些奇奇怪怪的语法还是时常提醒着我这是小程序，不是h5页面，而在用 ", "Taro", " 的时候，这个差异化已经被消磨得很少了。尽管还是有一定的限制，但我基本上就是用开发React的习惯来使用 ", "Taro", " ，可以说极大地提高了我的开发体验。", "一些需要注意的地方", "那 ", "Taro", " ，或者是小程序开发，有没有什么要注意的地方？当然有，走过的弯路可以说是非常多了。", "页面栈只有10层", "估计是每个页面的数据在小程序内部都有缓存，所以做了10层的限制。带来的问题就是假如页面存在循环跳转，即A页面可以跳到B页面，B页面也可以跳到A页面，然后用户从A进入了B，想返回A的时候，往往是直接在B页面里点击跳转到A， ", "而不是点返回", " 回到A，如此一来，10层很快就突破了。所以我们自己对 ", "navigateTo", " 函数做了一层封装，防止溢出。", "页面内容有缓存", "上面说到，页面内容有缓存。所以假如某个页面是根据不同的数据渲染视图，新渲染时会有上一次渲染的缓存，导致页面看起来有个闪烁的变化，用户体验非常不好。其实解决的办法也很简单，每次在 ", "componentWillUnmount", " 生命周期中清理一下当前页面的数据就好了。小程序说到底不是h5，不会说每次进入页面就会刷新，也不会离开就销毁，刷新 "]}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发", "author": "admin", "pub_time": "2016-10-12 22:14", "content": [" \n                     \n                    ", "编辑名片有两条路径，分为新增名片流程与修改名片流程。", "用户手填新增名片流程：", "首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。", "新增名片页面 1 基本布局如下：", "取到 userId。", "使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。", "也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。", "这里绑定了自带的模态框提示组件。", "其中 modalHidden2 是模态框开关。", "另外 proptText 是需要提示的内容。", "即使很多输入框也支持数据动态改变，非常方便。", "实际效果，非常快捷，比以前省去很多事情，编写", "小程序", "，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。", "最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。", "设置的直接是背景图片。", "提交表单与跳转。", "提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。", "这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。", "同样也是一些数据绑定以及验证效果。", "实际渲染效果可以看到。", "这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。", "修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：", "名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：", "姓名手机必填模块：", "个人信息模块，直接循环（block）出来：", "Onload 时我们请求必填与选填数据：", "* requiredGroup 必填中文信息", "* notRequiredGroup 选题中文信息", "* requiredGroupEn 必填英文信息", "* notRequiredGroupEn 选题英文信息", "```", "//请求名片对应的公司的中文信息的属性组数据，分为必填和选填", "//选题项变量以 no 开头", "requester.getOfflineCardInfoGroupFields(userId, cardId,", "function (res) {", "//debugger", "var userName = res.card.userName;", "var mobile = res.card.mobile;", "var requiredGroup = res.requiredGroupCh;", "var notRequiredGroup = res.notRequiredGroupCh;", "var requiredGroupEn = res.requiredGroupEn;", "var notRequiredGroupEn = res.notRequiredGroupEn;", "var reqLen = requiredGroup.fields.length;", "var nreqLen = notRequiredGroup.fields.length;", "var reqLenEn = requiredGroupEn.fields.length;", "var nreqLenEn = notRequiredGroupEn.fields.length;", "self.setData({", "userName: userName,", "mobile: mobile,", "requireFields: requiredGroup.fields,", "notRequireFields: notRequiredGroup.fields,", "requireFieldsEn: requiredGroupEn.fields,", "notRequireFieldsEn: notRequiredGroupEn.fields,", "l1: reqLen,", "l2: nreqLen + reqLen,", "l3: reqLenEn + nreqLen + reqLen", "});", "self.forceUpdate();", "}, function (code, msg) {", "console.info(\"code=\" + code + \"&msg=\" + msg);", "});", "```", "中英文信息必填与选填渲染：", "这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。", "今天再回去理下首页 A、B、C 定点跳转功能实现方法。", "首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：", "数据 sort，和 group.name 数据一样：", "这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。", "点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。", "首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。", "可以看下：", "这个 group.name==sortmsg，等于就是 A==A,B==B 同理。", "在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。", "跳转功能基本实现（ohter 就是 # 底部）。", " "]}
{"title": "精确计算微信小程序scrollview高度，全机型适配", "author": "Rolan", "pub_time": "2018-7-19 00:30", "content": [" \n                     \n                    ", "众所周知，可以滑动的 ", "scroll", " 组件在移动端非常的重要，几乎每个页面都要用到。", "而", "小程序", "的 ", "scroll-view", " 组件就比较坑了，非得指定一个高度才能正常使用。布局复杂的时候谁还给你算高度啊。。。", "坑归坑，没办法，还是得用……既然官方要求必须传高度，那就想办法计算吧。", "一、布局分析，推导公式", "先给个示例图：", "这是一个稍微复杂点的页面，最上面是两个 ", "tab", " 标签，每个标签的页面是一个子组件。第二个子组件布局是上面一个标题，下面是 ", "scroll-view", " 。", "再画个解剖图吧……", "页面分三部分，tab，title，scroll-view。不要忘了每个部分间还有 ", "margin", " , 这里设置的是每个 ", "margin", " 都是 ", "10px", " 。", "所以要计算 ", "scroll-view", " 的高度可以得出下面 ", "公式", " ：", "scroll-", "view", " 的高度 = 页面可用高度 - ", "tab", "高度 - title高度 - ", "10", " - ", "10", "\r\n复制代码", "为什么减两个 ", "10", " 呢？上面说了 ", "10", " 是 ", "margin", " 的距离， ", "tab", " 与 ", "title", " 有 ", "10px", " 的 ", "margin", "， ", "title", " 与 ", "scroll-view", " 也有 ", "10px", " 的 ", "margin", " 。", "需要注意的是计算用的单位都是 ", "px", " ，不是小程序的 ", "rpx", " 。因为下面调用接口获取可用屏幕高度时得到的就是 ", "px", " 。", "二、计算变量的高度", "2.1 计算单个节点高度", "上面的公式中的变量有：页面可用高度, ", "title", " 的高度， ", "tab", " 的高度。", "这里需要计算的就是 页面可用高度 和 ", "title", " 的高度，因为为了简单 ", "tab", " 的高度是写死的 ", "50px", " , 当然不写死也没关系，在父组件中计算 ", "tab", " 的高度传给子组件就好。", "下面正式开始计算", "//计算 scroll-view 的高度", "\r\ncomputeScrollViewHeight() {\r\n  ", "let", " that = ", "this", "\r\n  ", "let", " query = wx.createSelectorQuery().in(", "this", ")\r\n  query.select(", "'.title'", ").boundingClientRect(", "function", "(", "res", ") ", "{\r\n    ", "//得到标题的高度", "\r\n    ", "let", " titleHeight = res.height\r\n    ", "//scroll-view的高度 = 屏幕高度- tab高(50) - 10 - 10 - titleHeight", "\r\n    ", "//获取屏幕可用高度", "\r\n    ", "let", " screenHeight = wx.getSystemInfoSync().windowHeight\r\n    ", "//计算 scroll-view 的高度", "\r\n    ", "let", " scrollHeight = screenHeight - titleHeight - ", "70", "\r\n    that.setData({\r\n      ", "scrollHeight", ": scrollHeight\r\n    })\r\n  }).exec()\r\n},\r\n复制代码", "这里主要是通过小程序封装的 API 来计算的。", "wx.getSystemInfoSync()", " 可以得到设备的各种信息，关于高度的参数有两个，一个是屏幕高度 ", "screenHeight", " ，一个是可使用窗口高度 ", "windowHeight", " 。注意计算的时候要用 ", "windowHeight", " ，这样算出来的高度才是对的。 ", "screenHeight", " 是手机的屏幕高度，包含了手机的状态栏和小程序标题栏。", "有了可用屏幕高度，还需要元素的高度。计算元素高度小程序也提供了 API，参见WXML节点信息API。", "具体用法看文档就好了，精简的使用步骤就是：", "let", " query = wx.createSelectorQuery().in(", "this", ")\r\nquery.select(", "'.title'", ").boundingClientRect(", "function", "(", "res", ") ", "{\r\n    ", "//在这里做计算，res里有需要的数据", "\r\n}).exec()\r\n复制代码", "注意在组件 ", "component", " 里使用的话，要用 ", "wx.createSelectorQuery().in(this)", " ，将选择器的选取范围更改为自定义组件component内。（初始时，选择器仅选取页面范围的节点，不会选取任何自定义组件中的节点。）", "如果想同时测量多个节点的高度呢？", "2.2 计算多个节点高度", "能计算单个当然也能同时计算多个。如下：", "computeScrollViewHeight() {\r\n  ", "let", " that = ", "this", "\r\n  ", "let", " query = wx.createSelectorQuery().", "in", "(", "this", ")\r\n  query.", "select", "(", "'.search'", ").boundingClientRect()\r\n  query.", "select", "(", "'.title-wrapper'", ").boundingClientRect()\r\n  query.exec(res => {\r\n    ", "let", " searchHeight = res[", "0", "].height\r\n    ", "let", " titleHeight = res[", "1", "].height\r\n    ", "let", " windowHeight = wx.getSystemInfoSync().windowHeight\r\n    ", "let", " scrollHeight = windowHeight - searchHeight - titleHeight - ", "30", " - ", "5", " - ", "50", " \r\n    ", "this", ".setData({ scrollHeight: scrollHeight})\r\n  })\r\n},\r\n复制代码", "有几个节点就写几个 ", "query.select('.search').boundingClientRect()", " ， 然后调用 ", "query.exec()", " 执行操作获取节点信息的数组。", "注意：调用封装好的 ", "computeScrollViewHeight()", " 的时机是在生命周期函数的 ", "ready()", " 中，不能在 ", "created()", " ，否则取不到数据。", "参见Component构造器", "三、在 wxml 使用计算的结果", "计算完成后如何使用呢？", "<", "scroll-view", " ", "scroll-y", " ", "style", "=", "'height: ", "{{scrollHeight + \"px\"}", "}'", ">", "</<", "scroll-view", ">", "\r\n复制代码", "通过上面的方法使用。", "注意：一定要在变量后面加上单位 ", "px", " ，不加的话会出错。", "以上就是精确计算微信小程序scrollview高度的方法，从此再也不担心 ", "scroll-view", " 高度错乱了！", " "]}
{"title": "微信小程序Java登录流程（ssm实现具体功能和加解密隐私信息问题解决方案） ...", "author": "Rolan", "pub_time": "2018-7-19 00:06", "content": [" \n                     \n                    ", "文章有不当之处，欢迎指正，如果喜欢微信阅读，你也可以关注我的微信公众号： ", "好好学java", "，获取优质学习资源。", "一、登录流程图", "二、", "小程序", "客户端", "doLogin:", "function", "(", "callback = (", ") =>", "{}){\r\n", "let", " that = ", "this", ";\r\nwx.login({\r\n  ", "success", ":", "function", "(", "loginRes", ")", "{\r\n    ", "if", "(loginRes){\r\n      ", "//获取用户信息", "\r\n      wx.getUserInfo({\r\n        ", "withCredentials", ":", "true", ",", "//非必填  默认为true", "\r\n        success:", "function", "(", "infoRes", ")", "{\r\n          ", "console", ".log(infoRes,", "'>>>'", ");\r\n          ", "//请求服务端的登录接口", "\r\n          wx.request({\r\n            ", "url", ": api.loginUrl,\r\n            ", "data", ":{\r\n              ", "code", ":loginRes.code,", "//临时登录凭证", "\r\n              rawData:infoRes.rawData,", "//用户非敏感信息", "\r\n              signature:infoRes.signature,", "//签名", "\r\n              encrypteData:infoRes.encryptedData,", "//用户敏感信息", "\r\n              iv:infoRes.iv", "//解密算法的向量", "\r\n            },\r\n            ", "success", ":", "function", "(", "res", ")", "{\r\n              ", "console", ".log(", "'login success'", ");\r\n              res = res.data;\r\n              ", "if", "(res.result==", "0", "){\r\n                that.globalData.userInfo = res.userInfo;\r\n                wx.setStorageSync(", "'userInfo'", ",", "JSON", ".stringify(res.userInfo));\r\n                wx.setStorageSync(", "'loginFlag'", ",res.skey);\r\n                ", "console", ".log(", "\"skey=\"", "+res.skey);\r\n                callback();\r\n              }", "else", "{\r\n                that.showInfo(", "'res.errmsg'", ");\r\n              }\r\n            },\r\n            ", "fail", ":", "function", "(", "error", ")", "{\r\n              ", "//调用服务端登录接口失败", "\r\n             ", "// that.showInfo('调用接口失败');", "\r\n              ", "console", ".log(error);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }", "else", "{\r\n \r\n    }\r\n  }\r\n});\r\n}\r\n复制代码", "微信小程序端发起登录请求，携带的参数主要有：", "code", ":loginRes.code,", "//临时登录凭证", "\r\n    ", "rawData", ":infoRes.rawData,", "//用户非敏感信息", "\r\n    ", "signature", ":infoRes.signature,", "//签名", "\r\n    ", "encrypteData", ":infoRes.encryptedData,", "//用户敏感信息", "\r\n    ", "iv", ":infoRes.iv", "//解密算法的向量", "\r\n复制代码", "参数解释： code:loginRes.code,//临时登录凭证： ", "必传", " ，通过code来换取后台的 ", "sessionKey", "和 ", "openId", " rawData:infoRes.rawData,//用户非敏感信息 signature:infoRes.signature,//签名 encrypteData:infoRes.encryptedData,//用户敏感信息 iv:infoRes.iv//解密算法的向量", "signature,//签名、 ", "encryptedData", " ,//用户敏感信息、 ", "iv", " //解密算法的向量:", "这三个参数是用来解码用户敏感信息的，比如电话号码等信息。", "需要的数据主要有： ", "skey", " ，用于标志用户的唯一性。", "三、Java后台", "/**\r\n     * 登陆接口\r\n     */", "\r\n    ", "@RequestMapping(", "\"/login\"", ")", "\r\n    ", "@ApiResponses({\r\n            @ApiResponse(code = 404, message = ", "\"服务器未找到资源\"", ")", ",\r\n            ", "@ApiResponse(code = 200, message = ", "\"请求成功\"", ")", ",\r\n            ", "@ApiResponse(code = 500, message = ", "\"服务器错误\"", ")", ",\r\n            ", "@ApiResponse(code = 401, message = ", "\"没有访问权限\"", ")", ",\r\n            ", "@ApiResponse(code = 403, message = ", "\"服务器拒绝访问\"", ")", ",\r\n    })\r\n    ", "@ApiOperation(value = ", "\"小程序登录\"", ", httpMethod = ", "\"POST\"", ", notes = ", "\"小程序登录\"", ")", "\r\n    ", "public", " ResponseEntity<LoginDataResult> login(\r\n            ", "@ApiParam(required = true, value = ", "\"临时登录凭证code\"", ", name = ", "\"code\"", ")", " String code,\r\n            ", "@ApiParam(required = true, value = ", "\"用户非敏感信息\"", ", name = ", "\"rawData\"", ")", "\r\n            ", "@RequestParam(value = ", "\"rawData\"", ", required = true)", " String rawData,\r\n            ", "@ApiParam(required = true, value = ", "\"签名\"", ", name = ", "\"signature\"", ")", "\r\n            ", "@RequestParam(value = ", "\"signature\"", ", required = true)", " String signature,\r\n            ", "@ApiParam(required = true, value = ", "\"用户敏感信息\"", ", name = ", "\"encrypteData\"", ")", "\r\n            ", "@RequestParam(value = ", "\"encrypteData\"", ", required = true)", " String encrypteData,\r\n            ", "@ApiParam(required = true, value = ", "\"解密算法的向量\"", ", name = ", "\"iv\"", ")", "\r\n            ", "@RequestParam(value = ", "\"iv\"", ", required = true)", " String iv\r\n    ) {\r\n\r\n        ObjectMapper mapper = new ObjectMapper();\r\n\r\n        logger.info(", "\"signature=============================================================\"", "+signature);\r\n        logger.info(", "\"encrypteData==========================================================\"", "+encrypteData);\r\n        logger.info(", "\"iv========================================================================\"", "+iv);\r\n\r\n        RawData ", "data", " = ", "null", ";\r\n        WxMaJscode2SessionResult session = ", "null", ";\r\n        String openid = ", "null", ";\r\n        String sessionKey = ", "null", ";\r\n        String phoneNumber = ", "null", ";\r\n\r\n        ", "try", " {\r\n            ", "if", " (rawData != ", "null", " && !", "\"\"", ".equals(rawData)) {\r\n                ", "//1、获取用户非敏感信息", "\r\n                ", "data", " = mapper.readValue(rawData, RawData.", "class", ");\r\n            }\r\n            session = ", "this", ".wxService.getUserService().getSessionInfo(code);\r\n\r\n            ", "//获取到openid和sessionkey", "\r\n            openid = session.getOpenid();\r\n            sessionKey = session.getSessionKey();\r\n\r\n            logger.info(", "\"sessionkey=========================================================\"", "+sessionKey);\r\n\r\n          ", "/*  //2、获取用户手机号\r\n            phoneNumber = phone(code, signature, rawData, encrypteData, iv);\r\n\r\n            logger.info(\"phoneNumber=========================================\"+phoneNumber);\r\n*/", "\r\n        } ", "catch", " (IOException e) {\r\n            e.printStackTrace();\r\n            logger.info(", "\"获取用户信息失败\"", ");\r\n            LoginDataResult loginDataResult = new LoginDataResult();\r\n            loginDataResult.setCode(", "\"2\"", ");\r\n            loginDataResult.setMsg(", "\"请求失败\"", ");\r\n            ", "return", " ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(loginDataResult);\r\n        } ", "catch", " (WxErrorException e) {\r\n            e.printStackTrace();\r\n            logger.info(", "\"获取用户信息失败\"", ");\r\n        }\r\n\r\n        ", "//3、向数据库插入用户信息", "\r\n        String skey = insertUser(", "data", ", openid, phoneNumber);\r\n\r\n        ", "//4、缓存openid, sessionKey, skey到redis", "\r\n        redisCache(openid, sessionKey, skey);\r\n\r\n\r\n        ", "//5、把新的skey返回给小程序", "\r\n        LoginDataResult loginDataResult = new LoginDataResult();\r\n        loginDataResult.setSkey(skey);\r\n        loginDataResult.setCode(", "\"1\"", ");\r\n        loginDataResult.setMsg(", "\"请求成功\"", ");\r\n\r\n        ", "return", " ResponseEntity.status(HttpStatus.OK).body(loginDataResult);\r\n    }\r\n\r\n    ", "/**\r\n     * 缓存openid，sessionKey,skey等信息\r\n     * ", "@param", " openid 小程序用户唯一标志\r\n     * ", "@param", " sessionKey 小程序会话标志\r\n     * ", "@param", " skey 后台生成的用户唯一标志，会话管理\r\n     */", "\r\n    ", "private", " void redisCache(String openid, String sessionKey, String skey) {\r\n        ", "//根据openid查询skey是否存在", "\r\n        String skey_redis = jedisClient.hget(", "\"WEXIN_USER_OPENID_SKEY\"", ", openid);\r\n        ", "if", " (StringUtils.isNotBlank(skey_redis)) {\r\n            ", "//存在 删除 skey 重新生成skey 将skey返回", "\r\n            jedisClient.hdel(", "\"WEXIN_USER_OPENID_SKEY\"", ", openid);\r\n            jedisClient.hdel(", "\"WEIXIN_USER_SKEY_OPENID\"", ", skey_redis);\r\n            jedisClient.hdel(", "\"WEIXIN_USER_SKEY_SESSIONKEY\"", ", skey_redis);\r\n        }\r\n\r\n        ", "//  缓存一份新的", "\r\n        jedisClient.hset(", "\"WEXIN_USER_OPENID_SKEY\"", ", openid, skey);\r\n        jedisClient.expire(", "\"WEXIN_USER_OPENID_SKEY\"", ",", "432000", ");", "//设置5天过期", "\r\n        jedisClient.hset(", "\"WEIXIN_USER_SKEY_OPENID\"", ", skey, openid);\r\n        jedisClient.expire(", "\"WEIXIN_USER_SKEY_OPENID\"", ",", "432000", ");", "//设置5天过期", "\r\n        jedisClient.hset(", "\"WEIXIN_USER_SKEY_SESSIONKEY\"", ", skey, sessionKey);\r\n        jedisClient.expire(", "\"WEIXIN_USER_SKEY_SESSIONKEY\"", ",", "432000", ");", "//设置5天过期", "\r\n    }\r\n\r\n    ", "/**\r\n     * 将用户信息插入到数据库\r\n     * ", "@param", " data 用户信息\r\n     * ", "@param", " openid\r\n     * ", "@param", " phoneNumber 手机号\r\n     * ", "@return", "\r\n     */", "\r\n    ", "private", " String insertUser(RawData ", "data", ", String openid, String phoneNumber) {\r\n        ", "//判断用户数据库是否存在,不存在，入库。", "\r\n        Member user = userService.selectUserByOpenid(openid);\r\n        ", "//uuid生成唯一key", "\r\n        String skey = UUID.randomUUID().toString();\r\n        ", "if", " (user == ", "null", ") {\r\n            ", "//入库", "\r\n            user = new Member();\r\n            user.setId(skey);\r\n            user.setCountry(", "data", ".getCountry());\r\n            user.setCreatedate(new Date());\r\n            user.setDf(", "1", ");\r\n            user.setGender(", "data", ".getGender().equals(", "\"1\"", ") ? ", "1", " : ", "2", ");", "//1为男，2为女", "\r\n            user.setHeadimg(", "data", ".getAvatarUrl());\r\n            user.setNickname(", "data", ".getNickName());\r\n            user.setOpenid(openid);\r\n            user.setCitycode(", "data", ".getCity());\r\n            user.setProvincecode(", "data", ".getProvince());\r\n            user.setMobileno(phoneNumber);\r\n            ", "//插入到数据库", "\r\n            userService.insertUser(user);\r\n        } ", "else", " {\r\n            ", "//已存在", "\r\n            logger.info(", "\"用户openid已存在,不需要插入\"", ");\r\n            ", "return", " user.getId();", "//返回用户唯一标志skey", "\r\n        }\r\n        ", "return", " skey;\r\n    }\r\n\r\n    ", "/**\r\n     * 获取用户板绑定的手机号\r\n     * ", "@param", " sessionKey 小程序session\r\n     * ", "@param", " signature 签名\r\n     * ", "@param", " rawData 用户信息\r\n     * ", "@param", " encryptedData 小程序加密数据\r\n     * ", "@param", " iv 小程序向量\r\n     * ", "@return", "\r\n     */", "\r\n    ", "@ApiOperation(value = ", "\"用户手机号获取\"", ", httpMethod = ", "\"GET\"", ", notes = ", "\"用户手机号获取\"", ")", "\r\n    ", "public", " String phone(String sessionKey, String signature, String rawData, String encryptedData, String iv) {\r\n        String phoneNumber = ", "null", ";\r\n\r\n        ", "try", " {\r\n            byte[] bytes = WxMiniappUtils.decrypt(Base64.decodeBase64(sessionKey), Base64.decodeBase64(iv), Base64.decodeBase64(encryptedData));\r\n            String phone = new String(bytes, ", "\"UTF8\"", ");\r\n            logger.info(", "\"phone=====================================\"", "+phone);\r\n        } ", "catch", " (NoSuchPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (InvalidAlgorithmParameterException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (InvalidKeyException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (BadPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (IllegalBlockSizeException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (UnsupportedEncodingException e) {\r\n            e.printStackTrace();\r\n        }\r\n        ", "return", " ", "null", ";\r\n    }\r\n复制代码", "下面对上面代码进行分析：", "3.1获取openid和sessionKey", "session = this.wxService.getUserService().getSessionInfo(code);\r\n\r\n//获取到openid和sessionkey\r\nopenid = session.getOpenid();\r\nsessionKey = session.getSessionKey();\r\n复制代码", "这段代码是不是十分的简洁，这里用到了一个 ", "第三方的sdk（weixin-java-tools）", " ，通过这个sdk可以非常简便的获取到openid和sessionKey，具体的 ", "demo", " 。", "当然，如果你不想用 ", "第三方的sdk", " ，也可以自己实现，实现代码如下：", "public ", "static", " JSONObject getSessionKeyOrOpenId(", "String", " code){\r\n    ", "//微信端登录code", "\r\n    ", "String", " wxCode = code;\r\n    ", "String", " requestUrl = ", "\"https://api.weixin.qq.com/sns/jscode2session\"", ";\r\n    ", "Map", "<", "String", ",", "String", "> requestUrlParam = ", "new", " HashMap<", "String", ", ", "String", ">(  );\r\n    requestUrlParam.put( ", "\"appid\"", ",", "\"你的小程序appId\"", " );", "//小程序appId", "\r\n    requestUrlParam.put( ", "\"secret\"", ",", "\"你的小程序appSecret\"", " );\r\n    requestUrlParam.put( ", "\"js_code\"", ",wxCode );", "//小程序端返回的code", "\r\n    requestUrlParam.put( ", "\"grant_type\"", ",", "\"authorization_code\"", " );", "//默认参数", "\r\n \r\n    ", "//发送post请求读取调用微信接口获取openid用户唯一标识", "\r\n    JSONObject jsonObject = ", "JSON", ".parseObject( UrlUtil.sendPost( requestUrl,requestUrlParam ));\r\n    ", "return", " jsonObject;\r\n}\r\n复制代码", "3.2解密用户敏感数据获取用户信息", "3.2.1controller", "这个部分自己遇到了好多的坑，由于需要获取用户的手机号码，需要解密用户的信息。", "/**\r\n", "     * 获取用户板绑定的手机号", "\r\n", "     * @param sessionKey 小程序session", "\r\n", "     * @param signature 签名", "\r\n", "     * @param rawData 用户信息", "\r\n", "     * @param encryptedData 小程序加密数据", "\r\n", "     * @param iv 小程序向量", "\r\n", "     * @return", "\r\n", "     */", "\r\n    ", "@ApiOperation", "(value = ", "\"用户手机号获取\"", ", httpMethod = ", "\"GET\"", ", notes = ", "\"用户手机号获取\"", ")\r\n    public ", "String", " phone(", "String", " sessionKey, ", "String", " signature, ", "String", " rawData, ", "String", " encryptedData, ", "String", " iv) {\r\n        ", "String", " phoneNumber = ", "null", ";\r\n\r\n        ", "try", " {\r\n            byte[] bytes = WxMiniappUtils.decrypt(Base64.decodeBase64(sessionKey), Base64.decodeBase64(iv), Base64.decodeBase64(encryptedData));\r\n            ", "String", " phone = ", "new", " ", "String", "(bytes, ", "\"UTF8\"", ");\r\n            logger.info(", "\"phone=====================================\"", "+phone);\r\n        } ", "catch", " (NoSuchPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (InvalidAlgorithmParameterException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (InvalidKeyException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (BadPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (IllegalBlockSizeException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (UnsupportedEncodingException e) {\r\n            e.printStackTrace();\r\n        }\r\n        ", "return", " ", "null", ";\r\n    }\r\n复制代码", "3.2.2decrypt工具类", "这里调用了 ", "WxMiniappUtils.decrypt", " 这个工具类，工具类如下：", "/**\r\n     * 解密用户手机号算法\r\n     * ", "@param", " sessionkey 小程序登录sessionKey\r\n     * ", "@param", " iv 向量\r\n     * ", "@param", " encryptedData\r\n     * ", "@return", "\r\n     * ", "@throws", " NoSuchPaddingException\r\n     * ", "@throws", " NoSuchAlgorithmException\r\n     * ", "@throws", " InvalidAlgorithmParameterException\r\n     * ", "@throws", " InvalidKeyException\r\n     * ", "@throws", " BadPaddingException\r\n     * ", "@throws", " IllegalBlockSizeException\r\n     */", "\r\n    ", "public", " ", "static", " ", "byte", "[] decrypt(", "byte", "[] sessionkey, ", "byte", "[] iv, ", "byte", "[] encryptedData)\r\n            ", "throws", " NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,\r\n            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\r\n        AlgorithmParameterSpec ivSpec = ", "new", " IvParameterSpec(iv);\r\n        Cipher cipher = Cipher.getInstance(", "\"AES/CBC/PKCS5Padding\"", ");\r\n        SecretKeySpec keySpec = ", "new", " SecretKeySpec(sessionkey, ", "\"AES\"", ");\r\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\r\n        ", "return", " cipher.doFinal(encryptedData);\r\n    }\r\n复制代码", "这里用到的 ", "Cipher", " 类是 ", "javax.crypto", " 的类。", "3.2.3问题", "但是这里使用这个 ", "decrypt", " 工具类的时候，遇到了好多的问题。", "第一：AES解密是报错javax.crypto.BadPaddingException: pad block corrupted", "这个问题是由于，工具类使用了 ", "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", " 。", "解决：Cipher cipher = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");。", "第二：java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 这个问题是由于，解码出来的iv不是16位，好像是15位，这个为什么我也不太清楚。", "解决：这个怎么解决，自己也没有找到方法，如果有大神解决，望告知！", "我的解决方法：其实我发现这个问题并不是这个工具类的问题，我折腾了一天发现，这个工具类并不是不能够解码手机号，有的是可以的，有的解析不到手机号，只有普通的信息，所以我觉得，这个可能是微信用户注册的时候，是不是用手机号注册的，所以会出现有些能够解析，有的不能解析。如果有大神有其他方法，望告知！", "3.2.4解析成功数据", "{", "\"phoneNumber\"", ":", "\"13880684012\"", ",", "\"purePhoneNumber\"", ":", "\"13880684012\"", ",", "\"countryCode\"", ":", "\"86\"", ",", "\"watermark\"", ":{", "\"timestamp\"", ":", "1519460296", ",", "\"appid\"", ":", "\"wx6ede2086ee29a89f\"", "}}\r\n复制代码", "如果解析到了这样的json数据，说明是成功了的。", "3.2.5 另外一种方案", "public", " ", "class", " ", "AES", " ", "{\r\n    ", "public", " ", "static", " ", "final", " AES instance = ", "new", " AES();\r\n\r\n    ", "public", " ", "static", " ", "boolean", " initialized = ", "false", ";\r\n\r\n    ", "/**\r\n     * AES解密\r\n     * ", "@param", " content 密文\r\n     * ", "@return", "\r\n     * ", "@throws", " InvalidAlgorithmParameterException\r\n     * ", "@throws", " NoSuchProviderException\r\n     */", "\r\n    ", "public", " ", "byte", "[] decrypt(", "byte", "[] content, ", "byte", "[] keyByte, ", "byte", "[] ivByte) ", "throws", " InvalidAlgorithmParameterException {\r\n        initialize();\r\n        ", "try", " {\r\n            Cipher cipher = Cipher.getInstance(", "\"AES/CBC/PKCS7Padding\"", ");\r\n            Key sKeySpec = ", "new", " SecretKeySpec(keyByte, ", "\"AES\"", ");\r\n\r\n            cipher.init(Cipher.DECRYPT_MODE, sKeySpec, generateIV(ivByte));", "// 初始化", "\r\n            ", "byte", "[] result = cipher.doFinal(content);\r\n            ", "return", " result;\r\n        } ", "catch", " (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (NoSuchPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (InvalidKeyException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (IllegalBlockSizeException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (BadPaddingException e) {\r\n            e.printStackTrace();\r\n        } ", "catch", " (NoSuchProviderException e) {\r\n            ", "// TODO Auto-generated catch block", "\r\n            e.printStackTrace();\r\n        } ", "catch", " (Exception e) {\r\n            ", "// TODO Auto-generated catch block", "\r\n            e.printStackTrace();\r\n        }\r\n        ", "return", " ", "null", ";\r\n    }\r\n\r\n    ", "public", " ", "static", " ", "void", " ", "initialize", "()", "{\r\n        ", "if", " (initialized) ", "return", ";\r\n        Security.addProvider(", "new", " BouncyCastleProvider());\r\n        initialized = ", "true", ";\r\n    }\r\n\r\n    ", "//生成iv", "\r\n    ", "public", " ", "static", " AlgorithmParameters ", "generateIV", "(", "byte", "[] iv)", " ", "throws", " Exception", "{\r\n        AlgorithmParameters params = AlgorithmParameters.getInstance(", "\"AES\"", ");\r\n        params.init(", "new", " IvParameterSpec(iv));\r\n        ", "return", " params;\r\n    }\r\n}\r\n复制代码", "这个也会有上面的问题，有时候会解析失败！具体方法，还在摸索中，有大神知道方法和原有，望告知！", "3.2.6第三方sdk方法", "WxMaPhoneNumberInfo phoneNoInfo = ", "this", ".wxService.getUserService().getPhoneNoInfo(sessionKey, encryptedData, iv);\r\n        phoneNumber = phoneNoInfo.getPurePhoneNumber();\r\n复制代码", "这个也会有上面的问题出现，有时候会解析失败！", "四、总结", "1.小程序端发起请求并携带主要参数", "2.java后台接到/login请求后，根据code去调用微信接口获取用户唯一标识openid和sessionKey", "3.根据openid查询mysql数据库，判断该用户是否存在，如果不存在将用户非敏感信息和其他初始化数据存入到数据库中，如果已存在，不操作", "4.根据openid查询redis数据库，判断openid对应的skey是否存在，如果存在则删除原来老的skey以及对应的openid和sessionKey", "5.通过uuid生成唯一的skey，用openid做键，skey做值，存入到redis中", "6.然后把skey做键，openid和sessionKey的json串做值也重新存入到redis中", "7.根据解密算法，参数有encryptedData、sessionKey和iv，获取用户信息userInfo,如果userInfo字段不满足需要，可通过userInfo.put( \"balance\",user.getUbalance() );添加所需要的字段和值", "8.将微信小程序需要的数据封装到map中，返回给小程序端。", "参考资料（感谢）", "https://blog.csdn.net/abcwanglinyong/article/details/80267901", "https://github.com/binarywang/weixin-java-miniapp-demo", "https://www.cnblogs.com/nosqlcoco/p/6105749.html", "https://www.cnblogs.com/suxiaoqi/p/7874635.html", " "]}
{"title": "手把手教你搭建小程序音视频", "author": "Rolan", "pub_time": "2018-7-19 00:32", "content": [" \n                     \n                    ", "欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~", "本文由腾讯视频云终端团队 发表于云+社区专栏", "Demo 体验", "升级微信到最新版本，发现页卡 => ", "小程序", " => 搜索“腾讯视频云”，即可打开小程序Demo：", "注册小程序并开通相关接口", "出于政策和合规的考虑，微信暂时没有放开所有小程序对 <live-pusher> 和 <live-player> 标签的支持：", "个人账号和企业账号的小程序暂时只开放如下表格中的类目：", "主类目子类目", " 【社交】直播【教育】在线教育【医疗】互联网医院，公立医院【政务民生】所有二级类目【金融】基金、信托、保险、银行、证券/期货、非金融机构自营小额贷款、征信业务、消费金融", "打开微信公众平台 注册并登录小程序，并在小程序管理后台的<font color='red'> “设置 - 接口设置” </font>中自助开通该组件权限，如下图所示：", "注意：如果以上设置都正确，但小程序依然不能正常工作，可能是微信内部的缓存没更新，请删除小程序并重启微信后，再进行尝试。", "安装微信小程序开发工具", "下载并安装最新版本的微信开发者工具，使用小程序绑定的微信号扫码登录开发者工具。", "获取Demo源码并调试", "step1: 访问SDK + Demo，获取小程序 Demo 源码。", "step2: 打开安装的微信开发者工具，点击【小程序项目】按钮。", "step3: 输入小程序 AppID，项目目录选择上一步下载下来的代码目录（ ", "注意：", " 目录请选择 ", "根目录", " ，根目录包含有 ", "project.config.json", " 文件，请不要只选择 ", "wxlite", " 目录！），点击确定创建小程序项目。", "step4: 再次点击【确定】进入开发者工具。", "step5: 请使用手机进行测试，直接扫描开发者工具预览生成的二维码进入。", "step6: <font color='red'>开启调试模式</font>，体验和调试内部功能。开启调试可以跳过把这些域名加入小程序白名单的工作。", "Demo访问的测试地址", "Demo小程序会访问如下表格中的测试服务器地址，这些服务器使用的云服务是我们为大家提供的一个体验账号，平时很多客户都会在上面做测试。如果您希望使用自己的后台服务器，以免被其他客户打扰，请关注文档后一节内容：", "<live-room> 和 <rtc-room> 相关demo需要访问如下地址：", "<webrtc-room> 相关demo需要访问如下地址：", "搭建自己的账号和后台服务器", "这部分我们将介绍如何将Demo默认的测试用服务器地址，换成您自己的服务器，这样一来，您就可以使用自己的腾讯云账号实现上述功能，同时也便于您进行二次开发。", "1. 搭建 <webrtc-room> 的服务器", "1.1 这个服务器能做什么？", "点击demo里的互动课堂 ", "<webrtc-room>", " 功能，您会看到一个房间列表，这个房间列表是怎么实现的呢？", "在看到视频房间列表以后，如果你要创建一个视频房间，或者进入一个其他人建好的视频房间，就需要为 所对应的几个属性（ ", "sdkAppID", " 、 ", "userID", " 、 ", "userSig", " 、 ", "roomID", " 和 ", "privateMapKey", " ）传递合法的参数值，这几个参数值怎么获取呢？", "1.2 这个服务器要怎么搭建？", "下载 ", "webrtc_server", " ，这是一份 java 版本的实现，根据 README.md 中的说明就可以了解怎么使用这份源码。", "1.3 服务器建好了我怎么用？", "小程序", " 源码中，将 ", "wxlite/config.js", " 文件中的 ", "webrtcServerUrl", " 修改成：https://您自己的域名/webrtc/weapp/webrtc_room", "小程序实现 WebRTC 能力肯定是为了跟 Chrome 浏览器进行视频通话，浏览器端的源代码可以点击 ", "Chrome(src)", " 下载到，将 ", "component/WebRTCRoom.js", " 文件中的 ", "serverDomain", " 修改成：https://您自己的域名/webrtc/weapp/webrtc_room", "2. 搭建 <live-room> 和 <rtc-room> 的服务器", "2.1 这个服务器能做什么？", "（用于直播连麦）和 （用于视频通话）都是基于腾讯云 LVB 和 IM 两个基础服务实现的扩展功能，需要一个叫做 RoomService 的后台组件配合才能运行。", "2.2 这个服务器要怎么搭建？", "下载 ", "RoomService", " 的 java 版本源代码，根据 README.md 中的说明就可以了解怎么使用这份源码。", "2.3 服务器建好了我怎么用？", "小程序", " 源码中，将 ", "wxlite/config.js", " 文件中的 ", "serverUrl", " 和 ", "roomServiceUrl", " 修改成：https://您自己的域名/roomservice/", "小程序如果使用 <live-room> 和 <rtc-room> 两个标签，在 PC 端就不能用 Chrome 浏览器配对了，需要改用WebEXE 混合解决方案。将 ", "GitHub(WebEXE)", " 源码中 liveroom.html、double.html文件中的 ", "RoomServerDomain", " 修改成:https://您自己的域名/roomservice/", "3. Wafer 零成本服务器部署方案 （Node.js）", "如果您是一位资深的 Web 前端工程师，暂时找不到合适的服务器，但又想快速拥有自己的调试后台，可以使用腾讯云的 Wafer 功能进行零成本的一键部署方案（Wafer 只支持 Node.js 语言的后台代码），您需要你做的只是：", "step1: 下载 ", "小程序", " 源码。", "step2: 根据 ", "一键部署指引", " 完成部署。", "step3: 将 ", "GitHub(WebEXE)", " 源码中 liveroom.html、double.html文件中的 ", "RoomServerDomain", "修改成:https://您自己的域名/roomservice/", " "]}
{"title": "微信小游戏好友排行榜快速开发教程", "author": "Rolan", "pub_time": "2018-7-19 00:58", "content": [" \n                     \n                    ", "要做这个好友排行榜.必然要有好友的战绩比分,然后再做排序,最后将数据呈现在UI上 , 可以分为下面几个步骤:", "保存每个用户的分数", "获取好友列表,并获取好友的分数", "渲染排行榜", "保存每个用户的分数", "保存每个用户的分数,需要调用微信的云存储API,将用户的分数持久化的存起来 .", "// 保存用户数据,注意限制单条数据容量不得超过1024字节,", "\r\n", "// 单个用户数据总条数不得超过128条", "\r\nwx.setUserCloudStroage(", "Object", ")", "复制代码", "//存储最高分\r\nvar score = 100;\r\nvar kvScore = {", "\"key\"", ":", "\"score\"", ",", "\"value\"", ":score};\r\nwx.setUserCloudStroage({", "\"KVDataList\"", ":[kvScore]},", "\"success\"", ":", "function", "(){\r\n    //\r\n});", "复制代码", "获取好友列表,并获取好友的分数", "​ 游戏中将玩家的分数保存起来以后,需要调用微信的云存储API ", "wx.getFirendCloudStorage", ", 获取玩家的微信好友数据,这样就拿到了每个好友的最高分.", "值得一提的是,微信的这个接口在内部隐蔽的使用其微信的社交关系链 .", "返回列表中的包含的 调用过", "wx.setUserCloudStroage", " 这个接口的用户.", "渲染排行榜", "对分数进行排序 , 得到一个排行榜", "let", " sharedCanvas = wx.getSharedCanvas()\r\n\r\n", "function", " drawRankList (data) {\r\n  data.forEach((item, index) => {\r\n    // ...\r\n  })\r\n}\r\n\r\nwx.getFriendCloudStorage({\r\n  success: res => {\r\n    ", "let", " data = res.data\r\n    drawRankList(data)\r\n  }\r\n})", "复制代码", "注意这个 ", "sharedCanvas", " , 这是独有的画布 ,与小游戏中的画布不是同一个东东.", "使用sharedCanvas来自定义显示玩家的用户排行榜", "重要说明", "​ 上述所涉及的微信接口 , 都只能在微信小游戏的 ", "子域", " 使用 , 微信官网也称之为", "开放数据域", " , 其实应该称之为 ", "封闭数据域", " . ", "​ 为什么这么说呢?", "​ 因为子域的js代码执行环境和小游戏本身的代码执行环境是隔离的. 两者之间不能相通 , 子域只能接收外部的消息(如游戏的最高分),不能往外发消息(不能把用户的好友关系链数据发给开发者服务器) , 内存不共享,也就意味着,开发者拿不到微信的社交关系链数据 . 在这样的封闭条件下,开发者能做的只能是在子域的画布上将排行榜数据以个性化的UI元素展示出来 。", " "]}
{"title": "小程序开发技巧总结", "author": "Rolan", "pub_time": "2018-7-20 00:25", "content": [" \n                     \n                    ", "最近公司要开发一款电商", "小程序", "，匆忙看了一遍文档就开始干活了。整体开发体验个人感觉不太好，特别是如果之前习惯了Vue开发，突然去开发小程序，感觉很鸡肋。以下是我在开发中遇到的一些问题以及解决方法的总结，仅供参考", "引入iconfont", "在小程序中引入字体图标要比web麻烦一些，简单说需要三步：", "下载iconfont，把iconfont.css复制到iconfont.wxss，在app.wxss中引入", "查看iconfont在unicode模式下的在线链接，替换iconfont.wxss中的链接为远程链接", "在wxml文件中引入对应的icon class", "<icon ", "class", "=", "\"iconfont icon-pay\"", ">", "</", "icon", ">", "\r\n复制代码", "使用less", "vscode有一个easy less插件，是我感觉使用less最简单的方式", "vscode安装easy less插件", "创建一个less目录，用于存放less文件", "文件头部添加编译注释 ", "// out: ../pages/index/index.wxss, compress: true, sourceMap: false", "ctrl + s保存后自动编译", "编译后的结果", "按钮重置", "小程序中的按钮功能强大，很多功能必须要用按钮，比如弹出用户授权，调用客服功能。默认的样式一般无法满足需求，可以把按钮样式统一重置，然后自己写样式", "button", " {\r\n  ", "padding", ": ", "0", ";\r\n  ", "background", ": ", "#fff", ";\r\n  ", "line-height", ": ", "0", ";\r\n  &::after {\r\n    ", "border-color", ": transparent;\r\n  }\r\n}\r\n", ".button-hover", " {\r\n  ", "background", ": ", "#fff", ";\r\n}\r\n复制代码", "支持async-await", "async-await是ES7的语法，截止我写这篇文章为止，小程序还是不支持async-await语法的，所以需要使用regenerator这个库", "下载regenerator，并把regenerator-runtime并放到utils目录下", "2. 在util.js引入 ", "import regeneratorRuntime from './regenerator-runtime/runtime-module'", "封装wxRequest，让它支持async-await", "const", " wxRequest = ", "async", " (url, params = {}) => {\r\n  ", "Object", ".assign(params, {\r\n    ", "token", ": wx.getStorageSync(", "'token'", ")\r\n  })\r\n  ", "// 所有的请求，header默认携带token", "\r\n  ", "let", " header = params.header || {\r\n    ", "'Content-Type'", ": ", "'application/json'", ",\r\n    ", "'token'", ": params.token || ", "''", "\r\n  }\r\n  ", "let", " data = params.data || {}\r\n  ", "let", " method = params.method || ", "'GET'", "\r\n  ", "// hideLoading可以控制是否显示加载状态", "\r\n  ", "if", " (!params.hideLoading) {\r\n   wx.showLoading({\r\n     ", "title", ": ", "'加载中...'", ",\r\n   })\r\n  }\r\n  ", "let", " res = ", "await", " ", "new", " ", "Promise", "(", "(", "resolve, reject", ") =>", " {\r\n    wx.request({\r\n      ", "url", ": url,\r\n      ", "method", ": method,\r\n      ", "data", ": data,\r\n      ", "header", ": header,\r\n      ", "success", ": ", "(", "res", ") =>", " {\r\n        ", "if", " (res && res.statusCode == ", "200", ") {\r\n          resolve(res.data)\r\n        } ", "else", " {\r\n          reject(res)\r\n        }\r\n      },\r\n      ", "fail", ": ", "(", "err", ") =>", " {\r\n        reject(err)\r\n      },\r\n      ", "complete", ": ", "(", "e", ") =>", " {\r\n        wx.hideLoading()\r\n      }\r\n    })\r\n  })\r\n  ", "return", " res\r\n}\r\n\r\n", "export", " {\r\n  wxRequest\r\n}\r\n复制代码", "使用方法：", "import", " regeneratorRuntime ", "from", " ", "'../../utils/regenerator-runtime/runtime-module.js'", "\r\n", "import", " {\r\n  wxRequest\r\n} ", "from", " ", "'../../utils/util.js'", "\r\n\r\nPage({\r\n  ", "data", ": {\r\n   ", "list", ":[],\r\n   ", "count", ": ", "0", ",\r\n   ", "page", ": ", "1", ",\r\n   ", "limit", ": ", "10", "\r\n  },\r\n  ", "onLoad", ": ", "function", "(", ") ", "{\r\n    ", "this", ".getList()\r\n    ", "// 请求已经结束 做其他事", "\r\n  },\r\n  ", "getList", ": ", "async", " ", "function", "(", ") ", "{\r\n    ", "await", " wxRequest(app.globalData.baseUrl + ", "'/test'", ",{\r\n      ", "hideLoading", ": ", "true", ",\r\n      ", "data", ": {\r\n        ", "limit", ": ", "this", ".data.limit,\r\n        ", "page", ": ", "this", ".data.page\r\n      }\r\n    }).then(", "(", "ret", ") =>", " {\r\n      ", "this", ".setData({\r\n        ", "list", ": ret.data.data,\r\n        ", "count", ": ret.data.num\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码", "封装之后用起来还是很爽的，扩展起来也方便", "动态设置data中某个值", "应用场景：循环出来的列表，需要根据点击项，动态改变列表中对应id的数据", "// 动态传递id", "\r\n<block wx:", "for", "=", "\"{{list}}\"", " wx:key=", "\"{{index}}\"", ">\r\n  <view ", "catch", ":tap=", "\"onChangeName\"", " ", "data", "-id=", "\"{{item.id}}\"", "></view>\r\n</block>\r\n\r\nPage({\r\n  ", "data", ": {\r\n    list:[{\r\n      id: ", "0", ",\r\n      name: ", "'wang'", "\r\n    },{\r\n      id: ", "1", ",\r\n      name: ", "'li'", "\r\n    }]\r\n  },\r\n  onChangeName: function(event){\r\n    ", "// 拿到id", "\r\n   let id = event.target.dataset.id\r\n   let key = `list[${id}].name`, ", "val", " = ", "'zhang'", "\r\n   ", "// 设置值", "\r\n   ", "this", ".setData({\r\n    [key]: ", "val", "\r\n   })\r\n  }\r\n})\r\n复制代码", "flex布局，溢出省略号无效", "订单列表一般都是左边一个图片，右边是标题或描述。这时候图片宽度是固定的，标题长度自适应", ".wrap {\r\n  ", "display", ": flex;\r\n}\r\n.sub {\r\n  ", "flex", ": ", "1", ";\r\n  width: ", "0", "; ", "// 宽度设为0", "\r\n}\r\n.sub text {\r\n  ", "display", ": block; ", "// 一定要设置成block", "\r\n}\r\n\r\n<view calss=", "\"wrap\"", ">\r\n  ", "<", "image", " ", "src", "=", "\"i.png\"", "/>", "\r\n  ", "<", "view", " ", "class", "=", "\"sub\"", ">", "\r\n    ", "<", "text", ">", "一段文本一段文本一段文本一段文本一段文本一段文本", "</", "text", ">", "\r\n    ", "<", "view", ">", "其他", "</", "view", ">", "\r\n  ", "</", "view", ">", "\r\n", "</", "view", ">", "\r\n复制代码", "组件事件传递", "任务：父组件向子组件传递初始数据，当子组件点击以后可以triggerEvent自定义事件，父组件执行自定义事件，重新请求数据并传给子组件", "/* 子组件 */\r\n", "<view>", "\r\n  <", "view", " bind:tap=", "\"setId\"", " data-id=", "\"1\"", "></", "view", ">\r\n</", "view", ">\r\n\r\npropertie", "s:", " {\r\n  lis", "t:", " {\r\n    ", "type", ": Array,\r\n    defaul", "t:", " []\r\n  }\r\n},\r\n\r\nmethod", "s:", " {\r\n  setId(", "e", ") {\r\n    ", "let", " id = ", "e", ".currentTarget.dataset.id\r\n    this.triggerEvent(", "'deleteFav'", ", id)\r\n  }\r\n}\r\n\r\n/* 父页面 */\r\n<child bind:customEvent=", "\"deleteFav\"", "></child>\r\n\r\ndat", "a:", " {\r\n  lis", "t:", " []\r\n},\r\ndeleteFav(", "e", ") {\r\n  ", "let", " id = ", "e", ".detail // 获取传递过来的数据\r\n  // 根据id请求数据，然后重新setData\r\n  ", "let", " newData = [", "1", ",", "2", ",", "3", "]\r\n  this.setData({\r\n    lis", "t:", " newData\r\n  })\r\n}\r\n复制代码", "使用wxParse解析HTML", "下载 ", "wxParse", " ，放到utils目录下", "在JS页面引入： ", "import WxParse from '../../utils/wxParse/wxParse'", "Page({\r\n  ", "data", ":{\r\n    ", "contentHTML", ":", "''", " ", "// 解析后的HTML", "\r\n  },\r\n  ", "onLoad", ": ", "function", "(", ") ", "{\r\n    ", "// 请求到的HTML数据", "\r\n    ", "let", " content = ", "'<div>我是HTML代码</div>'", ", that = ", "this", ";\r\n    WxParse.wxParse(", "'contentHTML'", ", ", "'html'", ", content, that, ", "0", ");\r\n  }\r\n})\r\n\r\n复制代码", "显示解析内容", "<", "import", " ", "src", "=", "\"../../utils/wxParse/wxParse.wxml\"", "/>", "\r\n", "<", "view", ">", "\r\n  ", "<!-- 显示内容 -->", "\r\n  ", "<", "template", " ", "is", "=", "\"wxParse\"", " ", "data", "=", "\"", "{{wxParseData:contentHTML.nodes}", "}\"", " />", "\r\n", "</", "view", ">", "\r\n复制代码", "图片等比例", "image标签有个mode属性，可以设置图片如何显示，如果文档看的不仔细还真容易发现", "<", "image", " ", "src", "=", "\"test.png\"", " ", "mode", "=", "\"widthFix\"", "/>", "\r\n复制代码", "上拉加载和下拉刷新", "{\r\n  ", "\"onReachBottomDistance\"", ": ", "0", ",\r\n  ", "\"enablePullDownRefresh\"", ": ", "true", "\r\n}\r\n复制代码", "data", ": {\r\n  limit: ", "30", ",\r\n  page: ", "1", ",\r\n  list:[],\r\n  count:", "0", "\r\n},\r\n", "// 下拉", "\r\nonPullDownRefresh: function () {\r\n  ", "this", ".setData({\r\n    page: ", "1", ",\r\n    list:[]\r\n  })\r\n  ", "this", ".getData()\r\n},\r\n", "// 上拉", "\r\nonReachBottom: function () {\r\n  ", "if", "(", "this", ".", "data", ".list.length >= ", "this", ".", "data", ".count) {\r\n    ", "return", " ", "false", "\r\n  }\r\n  ", "this", ".setData({\r\n    page: ", "this", ".", "data", ".page + ", "1", "\r\n  })\r\n  ", "this", ".getData()\r\n  wx.stopPullDownRefresh()\r\n},\r\ngetData: async function () {\r\n  await wxRequest(app.globalData.baseUrl + ", "'/test'", ", {\r\n    ", "data", ": {\r\n      page: ", "this", ".", "data", ".page,\r\n      limit: ", "this", ".", "data", ".limit,\r\n    }\r\n  }).then((ret) => {\r\n    let list = ", "this", ".", "data", ".list.concat(ret.", "data", ".list)\r\n    ", "this", ".setData({\r\n      list: list,\r\n      count: ret.", "data", ".count\r\n    })\r\n  })\r\n}\r\n复制代码", "上传图片", "任务：小程序上传图片到服务器，最多上传三张，前端可以删除图片", "效果图如下", "使用到的API有两个：wx.uploadFile wx.chooseImage", "示例WXML：", "<", "view", " ", "class", "=", "\"sale after-pic\"", ">", "\r\n  ", "<", "block", " ", "wx:for", "=", "\"", "{{imgList}", "}\"", " ", "wx:key", "=", "\"", "{{index}", "}\"", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"pic\"", ">", "\r\n      ", "<", "image", " ", "src", "=", "\"", "{{item}", "}\"", " />", "\r\n      ", "<", "icon", " ", "type", "=", "\"clear\"", " ", "size", "=", "\"20\"", " ", "catchtap", "=", "\"clearImg\"", " ", "data-id", "=", "\"", "{{index}", "}\"", "/>", "\r\n    ", "</", "view", ">", "\r\n  ", "</", "block", ">", "\r\n  ", "<", "image", " ", "src", "=", "\"../../images/upload.png\"", " ", "catchtap", "=", "\"chooseImage\"", " />", "\r\n", "</", "view", ">", "\r\n", "<", "button", " ", "catchtap", "=", "\"onSub\"", ">", "提交", "</", "button", ">", "\r\n复制代码", "imgList是wx.chooseImage成功后返回的图片临时地址", "示例JS", "Page({\r\n  ", "data", ": {\r\n    ", "imgList", ":[]\r\n  },\r\n  ", "// 使用async await是因为图片上传是异步的", "\r\n  onSub: ", "async", " ", "function", "(", ") ", "{\r\n    ", "// 点击提交后，开始上传图片", "\r\n     ", "let", " imgUrls = []\r\n     ", "for", " (", "let", " index = ", "0", "; index < ", "this", ".data.imgList.length; index++) {\r\n       ", "await", " ", "this", ".uploadFile(", "this", ".data.imgList[index]).then(", "(", "res", ") =>", " {\r\n         ", "// 这里要注意把res.data parse一下，默认是字符串", "\r\n         ", "let", " parseData = ", "JSON", ".parse(res.data)\r\n         imgUrls.push(parseData.data) ", "// 图片地址", "\r\n       })\r\n     }\r\n     ", "console", ".log(imgUrls) ", "// 3张图片上传成功后，执行其他操作", "\r\n  },\r\n  ", "// 删除某张图片", "\r\n  clearImg: ", "function", " (", "params", ") ", "{\r\n    ", "let", " imgList = ", "this", ".data.imgList\r\n    ", "let", " id = params.currentTarget.dataset.id ", "// 图片索引", "\r\n    imgList.splice(id, ", "1", ") ", "// 删除", "\r\n    ", "this", ".setData({\r\n      ", "imgList", ": imgList\r\n    })\r\n  },\r\n  ", "chooseImage", ": ", "function", " (", "params", ") ", "{\r\n    wx.chooseImage({\r\n      ", "count", ": ", "3", ", ", "// 做多3张", "\r\n      sizeType: [", "'original'", ", ", "'compressed'", "],\r\n      ", "sourceType", ": [", "'album'", ", ", "'camera'", "],\r\n      ", "success", ": ", "(", "res", ") =>", " {\r\n        ", "// 存储临时地址", "\r\n        ", "this", ".setData({\r\n          ", "imgList", ": res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  ", "uploadFile", ": ", "function", " (", "filePath", ") ", "{\r\n    ", "// 返回Promise是为了解决图片上传的异步问题", "\r\n    ", "return", " ", "new", " ", "Promise", "( ", "(", "resolve, reject", ") =>", " {\r\n      wx.uploadFile({\r\n        ", "url", ": app.globalData.baseUrl + ", "'/file/upload'", ", ", "// 上传地址", "\r\n        filePath: filePath,\r\n        ", "name", ": ", "'file'", ", ", "// 这里的具体值，问后端人员", "\r\n        formData: {},\r\n        ", "header", ": {\r\n          ", "\"Content-Type\"", ": ", "\"multipart/form-data\"", "\r\n        },\r\n        ", "success", ": ", "(", "res", ") =>", "{\r\n          ", "// 图片上传成功后，后端会返回一个地址，可以把它存到imgUrls", "\r\n          ", "this", ".imgUrls.push(res.data.data)\r\n        },\r\n        ", "fail", ":", "(", "err", ") =>", " {\r\n          ", "console", ".log(err)\r\n        }\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码", "动态标题", "onLoad的时候动态设置标题", "wx", ".setNavigationBarTitle", "({\r\n  ", "title", ": ", "'新标题'", "\r\n})\r\n复制代码", "结语", "以上是仅为我个人在开发过程中遇到的一些问题，若有错误还请批评指正，感谢阅读.", " "]}
{"title": "微信小程序仿APP section header 悬停效果", "author": "Rolan", "pub_time": "2018-7-20 00:38", "content": [" \n                     \n                    ", "很多APP都有这么一个效果，列表头在滚动到顶部时会悬停在顶部，比如在iOS开发中UITableview设置 style 属性设置为 Plain ，这个tableview的section header在滚动时会默认悬停在界面顶端。", "那么我们怎么在微信", "小程序", "也实现这么一个效果呢？ ", "首先写一个非常简单列表：", "wxml代码", "<view", " ", "class", "=", "'header'", ">", "这里是header", "</view>", "<view", " ", "class", "=", "'section-header'", ">", "这是section-header", "</view>", " ", "<block", " ", "wx:for", "=", "\"{{testData}}\"", ">", "  ", "<view", " ", "class", "=", "'section-cell'", ">", "{{item}}", "</view>", "</block>", "wxss代码", ".", "header ", "{", "  height", ":", " ", "300rpx", ";", "  width", ":", " ", "750rpx", ";", "  background", "-", "color", ":", " bisque", ";", "  margin", "-", "bottom", ":", " ", "10rpx", ";", "}", ".", "section", "-", "header ", "{", "  height", ":", " ", "80rpx", ";", "  width", ":", " ", "750rpx", ";", "  background", "-", "color", ":", " rebeccapurple", ";", "}", ".", "section", "-", "cell ", "{", "  height", ":", " ", "180rpx", ";", "  width", ":", " ", "750rpx", ";", "  background", "-", "color", ":", " gold", ";", "  margin", "-", "top", ":", " ", "10rpx", ";", "}", "简单列表效果.png ", "那我们要怎么样让头部悬停呢？", "1、我们需要在页面布局完成后获取到头部的位置：", "在onReady方法中，查询section-header节点并拿到该节点此时距离当前顶部的距离", "注意是 此时，这个后面再讲", "  ", "/**", "   * 页面加载完成", "   */", "  onReady", ":", " ", "function", " ", "()", " ", "{", "    ", "let", " that ", "=", " ", "this", "    ", "let", " query ", "=", " wx", ".", "createSelectorQuery", "()", "    query", ".", "select", "(", "\".section-header\"", ").", "boundingClientRect", "(", "function", " ", "(", "res", ")", " ", "{", "      ", "// console.log(res)", "      that", ".", "setData", "({", "        ", "//section header 距离 ‘当前顶部’ 距离", "        sectionHeaderLocationTop", ":", " res", ".", "top", "      ", "})", "    ", "}).", "exec", "()", "  ", "},", "2、我们需要监听页面滚动：", "fixed用来控制是否悬停", "  ", "/**", "   * 页面滚动监听", "   */", "  onPageScroll", ":", " ", "function", " ", "(", "e", ")", " ", "{", "    ", "//console.log(e)", "    ", "this", ".", "setData", "({", "      scrollTop", ":", " e", ".", "scrollTop", "    ", "})", "    ", "if", " ", "(", "e", ".", "scrollTop ", ">", " ", "this", ".", "data", ".", "sectionHeaderLocationTop", ")", " ", "{", "      ", "this", ".", "setData", "({", "        ", "fixed", ":", " ", "true", "      ", "})", "    ", "}", " ", "else", " ", "{", "      ", "this", ".", "setData", "({", "        ", "fixed", ":", " ", "false", "      ", "})", "    ", "}", "  ", "},", "3、修改相应的样式：", "将原来的header修改为如下代码，并添加一个placeholder视图，目的是当我们的section-header视图悬停时，保持占位，避免页面抖动", "<view", " ", "class", "=", "'{{fixed ? \"section-header section-fixed\": \"section-header\"}}'", ">", "这是section-header", "</view>", "<view", " ", "hidden", "=", "'{{!fixed}}'", " ", "class", "=", "\"section-header section-placeholder\"", "></view>", " ", "增加wxss代码", ".", "section", "-", "placeholder ", "{", "  background", "-", "color", ":", " white", ";", "}", ".", "section", "-", "fixed", " ", "{", "  position", ":", " ", "fixed", ";", "  top", ":", " ", "0", ";", "}", "附上js data 代码:", "  data", ":", " ", "{", "    testData", ":[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "10", "],", "    ", "//section header 距离 ‘当前顶部’ 距离", "    sectionHeaderLocationTop", ":", " ", "0", ",", "    ", "//页面滚动距离", "    scrollTop", ":", " ", "0", ",", "    ", "//是否悬停", "    ", "fixed", ":", " ", "false", "  ", "},", "此时我们需要的效果就实现了：", "sectionHeader悬浮.gif ", "这个有一个要注意的点，我们在使用swlectorQuery()的时候，获取到的top是当前调用改函数时相应节点对应当前顶部的距离，这就有一个问题，当我们的header的高度（不一定是header只要是section-header上面的视图的高度）发生变化的时候，悬停就会有问题，因为我们的高度是最开始的时候获取的。", "所以在我们改变高度之后，要再次调用该函数去获取距离\"当前顶部\"的距离，这也是要注意的一个点，如果我能直接再次获取并赋值，发现还是有问题，就是因为此时获取的top不是距离整个page页面顶部，而我们监听的页面滚动却是，所以我们可以修改代码如下：", "  ", "let", " that ", "=", " ", "this", "    ", "let", " query ", "=", " wx", ".", "createSelectorQuery", "()", "    query", ".", "select", "(", "\".section-header\"", ").", "boundingClientRect", "(", "function", " ", "(", "res", ")", " ", "{", "      ", "// console.log(res)", "      that", ".", "setData", "({", "        ", "//section header 距离 ‘当前顶部’ 距离", "        sectionHeaderLocationTop", ":", " res", ".", "top ", "+", " that", ".", "data", ".", "scrollTop", "      ", "})", "    ", "}).", "exec", "()", "加上此时页面滚动的距离，则能保证我们预期的效果出现！！！！", " "]}
{"title": "小程序开发心得", "author": "Rolan", "pub_time": "2018-6-23 00:08", "content": [" \n                     \n                    ", "今天是来杭州的第三个月后的十几天，正是的现在这份工作转正的日子。几天前转正面谈时 CTO 对于前几个月的工作给予了肯定，同时也提了几点建议。这也是这篇文章存在原因之一。", "要养成一些好的习惯、好的方法、并学会分享。这些好的习惯以后会跟着你走。", "来杭州三个月，也习惯了这里的生活。在新的公司做了两三个小项目，也研究了几个以前没有仔细研究的技术。小有收获。最近一周一直在忙两个项目，一是智能柜，二是景区。以下是我最近开发的一些心得和技巧：", "在开发微信", "小程序", "时，我们可以将小程序中常用的基本配置统一抽离出来放在一个config.js中如下：", "const", " SERVER_URL = ", "'http", ":", "//www.xxx.com/api';", "\r\n", "const", " TEST_SERVER_URL = ", "'http", ":", "//test.xxx.com/api';", "\r\n", "const", " CDN_URL = ", "'http", ":", "//cdn,xxx.com';", "\r\n", "const", " TEST_CDN_URL = ", "'http", ":", "//tcdn.xxx.com';", "\r\n\r\nexport CONFIG_PRODUCT = {\r\n    SERVER_URL,\r\n    CDN_URL,\r\n    DEBUG_FLAG:", "false", ",\r\n    TEST_FLAG:", "false", ",\r\n}\r\n\r\nexport CONFIG_TEST = {\r\n    SERVER_URL:TEST_SERVER_URL,\r\n    CDN_URL:TEST_CDN_URL,\r\n    DEBUG_FLAG:", "true", ",\r\n    TEST_FLAG:", "false", ",\r\n}", "然后按照开发需求引入这些配置信息（如 控制console.log），在后期方便配置的统一管理和维护。", "对网络请求（wx.request）进行二次封装如下例：", "import", " { CONFIG } ", "from", " ", "'./config'", ";\r\n", "import", " MD5 ", "from", " ", "'./md5'", "/**\r\n* 定制功能的网络请求方法\r\n* @param options object\r\n* @property url string 请求的资源地址，在请求时会自动添加服务器地址。\r\n* @property data object 请求所携带的参数\r\n* @property header object 请求头\r\n* @property success function 请求成功的回调\r\n* @property fail function 请求失败的回调\r\n* @property complete function 请求完成的回调\r\n* \r\n* 功能简介：\r\n* 传入与 wx.request 相同的参数，方法内部会对几个重要部分进行功能根据项目需求强化，如在 header \r\n* 中添加验证字段，对 POST 方法时将 header 的 content-type 改为对应参数。对特定的 状态码（400）\r\n* ，进行处理。\r\n* \r\n*/", "\r\n", "export", " ", "default", " (options) => {\r\n  ", "const", " { ", "APP_CONFIG", ": { SERVER_URL, DEBUG_FLAG,SPEACAL_SERVER_URL } } =   CONFIG;\r\n  ", "if", " (DEBUG_FLAG) {\r\n      ", "console", ".group(", "'网络请求'", ");\r\n      ", "console", ".log(options);\r\n  }\r\n  ", "if", " (!options.anotherFlag) {\r\n      wx.showLoading({\r\n           ", "title", ": ", "'正在加载'", "\r\n      })\r\n  }\r\n  ", "if", " (options.anotherFlag) {\r\n     ", "let", " String1 = ", "''", "\r\n     ", "const", " { ", "data", ":{query,mainData} } = options\r\n     query.time = ", "Math", ".ceil(", "Date", ".now() / ", "1000", ");\r\n     ", "const", " dataKeyArray = ", "Object", ".keys(query).sort();\r\n     dataKeyArray.forEach(", "(", "e, i", ") =>", " {\r\n                                      ", "if", " (i === ", "0", ") {\r\n                                           String1 += ", "`", "${e}", "=", "${query[e]}", "`", ";\r\n                                      } ", "else", " {\r\n                                           String1 += ", "`&", "${e}", "=", "${query[e]}", "`", ";\r\n                                      }\r\n                                    })\r\n     ", "const", " String2 = ", "`", "${String1}", "&secret=yoursalt`", ";\r\n     ", "const", " token = MD5(String2);\r\n     options.url = ", "`", "${SPEACAL_SERVER_URL}", "token=", "${token}", "`", ";\r\n     options.header = modifyHeader(options.header);\r\n     options.header[", "'Content-Type'", "] = ", "'application/json'", ";\r\n     options.method = ", "'POST'", ";\r\n     options.data = mainData;\r\n  } ", "else", " {\r\n     options.url = ", "`", "${SERVER_URL}", "${(options.url) ? ", "'/'", " + options.url : ", "''", "}", "`", ";\r\n     options.header = modifyHeader(options.header);\r\n     options.method = ", "'POST'", ";\r\n  }\r\n   ", "if", " (", "typeof", " options === ", "'object'", ") {\r\n      ", "const", " success = options.success;\r\n      ", "const", " fail = options.fail;\r\n      ", "const", " complete = options.complete;\r\n      options.success = success ? ", "res", " =>", " {\r\n        ", "if", " (DEBUG_FLAG) {\r\n          ", "console", ".log(res);\r\n          ", "console", ".groupEnd();\r\n        }\r\n        ", "if", " (res.flag !== ", "0", " && !options.anotherFlag) {\r\n          fail ? fail(res) : ", "''", ";\r\n        } ", "else", " {\r\n          success(res);\r\n        }\r\n     } : ", "null", ";\r\n\r\n    options.fail = fail ? ", "res", " =>", " {\r\n       ", "if", " (DEBUG_FLAG) {\r\n         ", "console", ".log(res);\r\n         ", "console", ".groupEnd();\r\n       }\r\n         fail(res);\r\n    } : ", "null", ";\r\n\r\n    options.complete = complete ? ", "res", " =>", " {\r\n       ", "if", " (DEBUG_FLAG) {\r\n          ", "console", ".groupEnd();\r\n       }\r\n       ", "if", " (!options.anotherFlag) {\r\n         wx.hideLoading();\r\n       }\r\n       complete(res);\r\n    } : ", "()", " =>", " {\r\n      ", "if", "(!options.anotherFlag){\r\n         wx.hideLoading();\r\n      }\r\n    };\r\n  }\r\n  wx.request(options);\r\n}\r\n\r\n", "const", " modifyHeader = ", "header", " =>", " {\r\n    ", "const", " token = wx.getStorageSync(", "'token'", ");\r\n    ", "if", " (token) {\r\n       ", "return", " { ...header, ", "token", ": ", "`", "${token}", "`", " };\r\n    } ", "else", " {\r\n       ", "return", " (header) ? header : {};\r\n    }\r\n};", "当然也可以根据个人的开发习惯进行 promise 封装。这样封装的好处也显而易见，方便对所有的 request 进行监控，通用逻辑的修改，方便调试和开发。", "在写些小程序的条件动画时，也可以十分方便如下：", "// page.wxss", "\r\n.css-a{\r\n    transform:translate3d(", "-100", "%,", "0", ",", "0", "); ", "// 将 css-a 元素上移全部高度", "\r\n    transition:all ", ".5", "s;\r\n}\r\n\r\n.css-a.show{\r\n    transform:translage3d(", "0", ",", "0", ",", "0", "); ", "// 将 css-a 元素动画回原位", "\r\n}\r\n\r\n", "// page.wxml", "\r\n\r\n<view ", "class", "=", "'css", "-a {{showFlag ? ", "\"show\"", ":", "\"\"", "}}'>动画", "DEMO", "</view>\r\n\r\n", "// page.js", "\r\n\r\n", "// 触发的动画事件", "\r\n  onTrigger(){\r\n     ", "this", ".setData({showFlag:", "true", "});\r\n  }", "通过绑定点击、触摸事件，就能够实现很多简单的动画，提升人机交互的乐趣。", " "]}
{"title": "扫码付小程序优化实践", "author": "Rolan", "pub_time": "2018-7-23 00:12", "content": [" \n                     \n                    ", "前几日作者在掘金上看到了", "【微信小程序性能优化】", "这篇文章，当时心想这个团队做的事情和我们方向很相似，仔细一看原来是微信公开课上", "小程序", "专场中“小程序性能优化”模块的记录，而其中我们提出的建议（", "独立分包", "）也即将发布。借着这个机会，我们也决定把在", "扫码付小程序中的一些优化实践分享出来。作者：", " ", "@陈小二", " ", "@simpxu", "什么是扫码付小程序？", "美团扫码付小程序是一款面向C端消费者推出的线下收单业务。它寄托在美团小程序下，在实际场景中，用户先使用微信扫一扫扫描商家二维码，接着调起扫码付小程序，进入支付页后输入金额向商家完成商品支付。", "扫码付小程序功能图", "我们的目标？", "我们一直在做一件事情：", "提升扫码付小程序的支付转化率", "。这里所提的支付转化率指：整个业务流程中用户成功支付到扫码的占比。支付转化率与扫码付业务来讲，百分比越高，扫码付业务的营业额收入越高，带来的收益是成正比的。", "而这部分转化率流失的影响，我们认为包含两个部分：", "扫码到进入小程序环节（外部环节）", "进入小程序到支付环节（内部环节）", "在扫码到进入小程序环节，微信会完成", "小程序基本信息获取、资源准备", "（代码下载或更新）等准备事项，在准备事项中若准备失败或时间过长会导致用户手动离开，这部分由微信控制的环节称之为外部环节；在进入小程序到支付环节，页面会进行渲染、数据请求等，如果渲染时间长、数据请求时间长也易导致用户手动离开，而数据请求失败也会造成用户使用流程终止而离开，这部分由我们自己控制的环节称之为内部环节。", "如何提升外部环节转化率？", "对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们无法得知此处的细节。而我们在扫码付小程序中尝试和微信的同学做了一次梳理，发现扫码付小程序在外部环节的丢失率较高，查询数据发现其中大部分用户手动点击了右上角的退出。从业务出发，用户使用扫码付可以认为用户是有强需求进行支付，能够造成用户手动点击退出的行为部分原因可能来自于等待时间较长，而在这个环节对时间造成影响更多的是", "资源准备", "，即小程序代码下载或者更新的行为。", "影响下载和更新时间可能的因素有：", "网络", "代码包", "用户网络是我们无法控制的，只能尝试从代码包开始下手。而在当时未使用分包的情况下，我们的主包大小约3M，意味着新用户和无缓存小程序用户均需要在首次使用时等待下载3M左右的包大小，在这种情况下虽然用户享受了小程序离线缓存包的福利，却丢失了大部分新用户的体验。于是我们尝试从包代码大小做了一些优化：", "增加分包加载机制", "。用户在使用扫码付业务时会按需进行加载，优化小程序首次启动的下载时间。", "减小主包和分包大小", "。按照空主包的概念进行优化。在进行分包加载机制后，主包无法最小化依然影响首次下载时间。一方面，原有的3M整包中，图片大小占用了50%大小，我们将所有的内含二进制和Base64图片分发到了CDN；另一方面，部分可移出的业务分发到了其他分包。", "在做了这些事情后，扫码付分包从原先的整包3M缩减到了361k(主包300k+分包61)，而外部环节的转化率也提升了3%。虽然转化率提升了，但前置环节的转化率仍然有部分丢失，理论上继续缩减300k的主包能有效提升，但由于业务性质的原因无法再继续缩减，于是我们向微信小程序提出了独立分包的概念:", "用户在使用独立分包时无需下载主包", "。通过独立分包加载，程序使用期间下载更新阶段只需要加载61k的分包大小，目前这个功能还在内测阶段，扫码付小程序也在作为第一批的内测用户进行体验，优化效果在之后的实践中我们也会分享出来。", "如何提升内部环节转化率？", "在进入小程序到支付这个环节，属于我们的业务流程。在这个环节中的转化率丢失虽然是我们能掌控的，但我们并无头绪，所以我们做了一些数据监控来寻求方法：", "业务核心流程监控", "。业务核心流程指用户进入小程序后所涉及到的影响最终支付的中间流程，中间流程的丢失直接影响业务整个转化率丢失，所以它们是必须监控的。而业务核心流程监控需要可监控的具体指标，我们对进入小程序和支付进行了关键动作拆解，从扫码到用户看到页面、再到点击支付、初始化订单、支付成功。拆解完这些关键动作，再针对每一步可控环节，进行技术指标的拆解。从入口到出口的每一步制定关键指标（扫码加载转化率、点击意愿等，见下图），形成一个至上而下的漏斗，产出多个可量化指标，来做业务流程的监控。对于这部分可量化指标，通过长期的观察分析来提升转化率。", "异常监控", "。页面的任何异常都可能导致支付页面的渲染失败，从而无法正常支付。我们对页面的接口异常、微信API异常进行了监控。接口异常可在API（wx.request)的fail函数中直接捕获，从而上报监控；对于接口超时，则只能通过全局的app.json进行全局设置（默认60s，时间过长，对用户体验较差），此前我们曾尝试在小程序中设置全局的5s请求超时，但实际应用中并非所有场景需要设置统一的超时，最终我们单独封装了接口请求超时。微信API的异常通过微信的一些fail中进行监控即可。", "性能监控", "。小程序内部转化环节中关注进入小程序后的白屏时间和可交互时间。内部白屏时间从onLoad处打点，到页面onReady处结束；内部可交互时间从onLoad处打去kjnpl0o09o0点，到页面数据请求结束后的可点击支付时间截止。", "日常监控中，我们也发现了一些问题，例如接口调用超时、接口调用失败，这些问题会导致页面流程终止。针对这些问题，做了一些优化：", "接口合并", "。支付页面的外网链路接口请求数量较多，任意一个接口的失败都会导致问题，合并接口则可以减少问题出现概率，提升中间流程的转化率。", "增加重试机制", "。在出现接口异常的情况下，会直接导致页面阻塞，如果通过重试能成功，则可以提升转化率。整个流程中可重试的有两类：", "自有的接口请求异常", "小程序API调用异常", "对于这两类异常，在接口超时、调用失败时采取重试。而为了避免在极端情况下服务端流量陡增、峰值倍数增加，页面的可重试次数会在前置获取全局配置时根据“可重试次数”控制，并且每次重试需要在一段时间后用户手动触发。超过重试次数时，则流程终止。", "如何监控内部和外部环节？", "前面我们也提到，对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们开发者无法得知此处的细节，所以说在监控外部环节这方面我们开发者似乎可做的事情屈指可数。但是，不知道细心的同学有没有发现，微信在每次扫码后会给我们在query参数上附带一个scancode_time字段。其实这个字段表示的是", "用户在使用扫一扫时微信服务端记录的时间", "，所以基于这个字段的考量，我们做了如下尝试，针对以下两个参数值分别做了实时监控：", "支付页面的白屏时间（用户看到首屏的客户端时间—用户微信扫一扫服务端时间+服务端客户端差额时间）", "支付页面的用户可交互时间（页面Loading完毕时间—用户微信扫一扫服务端时间+服务端客户端差额时间）", "Tips：由于客户端的时间戳是获取本地手机系统的时间，可能存在差异。所以为了保证上报的准确性，我们在每次onLoad的时候取了一次我们服务端的时间，记录了客户端的时间与服务端的一个时间差额，并且在后续所有涉及到服务端的时间都参照这个时间差额做计算（网络100-200ms级别的传输时延暂可忽略）", "但由于我们扫码付小程序的特殊应用场景就是为了保障用户进行快速可靠的支付，既然在外部环节可控度不高，那是不是可以考虑在内部的业务流程方面把监控统计做的细粒度一点，做到能对每一个可能影响到支付的环节有数据可循呢？所以我们针对这个方向，区别于传统的pv、uv统计，对业务上报做了如下分类：", "根据上报的场景划分：实时性监控部分与统计部分", "根据上报的类型划分：Error类型、Event类型（普通生命周期事件）、Metric类型（自定义Event类型，维度可自定义）、自定义测速类型（延时趋势与分布）", "基于上述方案的探索，我们小组基本上做到了对可能影响支付环节的某些业务指标的把控。从而在下一步，可以针对每个潜在的可优化点做进一步思考与考量，作出及时的策略优化与更新。", "总结", "通过对扫码付小程序的探索，我们积累了比较宝贵的优化经验，不过对于能优化的方面，还需要我们更进一步探索，距离我们的目标还很远。当然如果你有兴趣，我们更希望你能加入我们，一起探索未来。所以这里呢也打个广告，", "对我们“智能支付大前端团队”有兴趣的同学可直接简历发送给陈小二同学（chenyao05@meituan.com）。", " "]}
{"title": "简单谈谈setTimeout与setInterval", "author": "Rolan", "pub_time": "2018-7-23 00:23", "content": [" \n                     \n                    ", "感谢踩过的坑", "sf社区的第一篇文章。", "最近在做一个拍卖的微信", "小程序", "，用到了定时器setTimout和setInterval,简单谈谈这两个api。", "setTimeout", "最常见的用法就是第二种(第三种mdn文档不推荐)，如:", "var", " timeoutId = setTimeout(", "function", "(", ") ", "{\r\n    ", "console", ".log(", "'hello world!'", ")\r\n},", "1000", ")\r\n", "定时器是先等待1000ms再执行function的语句，而不是一开始就执行然后再等待。如果执行的语句需要用到this引用，需要在回调函数function上绑定this：", "function() {...}.bind(this)", "，把this传给回调函数，同作为该回调函数的this，使回调函数内外this的指向保持一致。或者用es6的箭头函数", "() => {}", "，也能起到同样的作用。bind的用法详见", "Function.prototype.bind()", "用完定时器之后，要", "记得清除", "：", "clearTimeout(timeoutId)", " 这里的timeoutId是setTimeout返回的一个正整数编号，是定时器的唯一标识符。", "setInterval", "在我看来基本上可以当成setTimeout的升级版，就像setTimeout循环调用自身，用法也跟setTimeout一样，用完是也要记得用clearInterval清掉定时器。底层原理或许会有些不同，这里就不深究。", "下面是我在微信小程序倒计时组件：", "// components/countdown.js", "\r\n", "/**\r\n * 倒计时组件\r\n */", "\r\nComponent({\r\n  ", "/**\r\n   * 组件的属性列表\r\n   */", "\r\n  properties: {\r\n    ", "durationInit", ": {\r\n      ", "type", ": ", "Number", ",\r\n      ", "value", ": ", "0", ",\r\n      ", "observer", ": ", "function", "(", "newVal", ") ", "{  ", "//监控duration初始值变动(看有没有外部传入新的时间)", "\r\n        ", "this", ".initDuration(newVal)\r\n      }\r\n    }\r\n  },\r\n\r\n  ", "/**\r\n   * 组件的初始数据\r\n   */", "\r\n  data: {\r\n    ", "duration", ": ", "0", ", ", "//剩余时间,单位秒", "\r\n    timeDisplay: ", "''", " ", "//展示时间", "\r\n  },\r\n  ", "intervalId", ": ", "null", ", ", "//计时器Id,不需要渲染，放外面，免得影响性能", "\r\n\r\n  ", "/**\r\n   * 组件销毁了要清除计时\r\n   */", "\r\n  detached() {\r\n    ", "this", ".stopInterval(", "this", ".intervalId)\r\n  },\r\n\r\n  ", "/**\r\n   * 组件的方法列表\r\n   */", "\r\n  methods: {\r\n    ", "// 设置时间", "\r\n    setTime: ", "function", "(", "duration", ") ", "{\r\n      ", "if", " (duration <= ", "0", ") {\r\n        ", "this", ".setData({\r\n          ", "timeDisplay", ": ", "`活动结束啦`", "\r\n        })\r\n        ", "//this.data.timeDisplay = `活动结束啦，戳这里看看好东西~`", "\r\n        ", "return", " ", "false", "\r\n      }\r\n      ", "var", " s = ", "this", ".formatTime(duration % ", "60", ")\r\n      ", "var", " m = ", "this", ".formatTime(", "Math", ".floor(duration / ", "60", ") % ", "60", ")\r\n      ", "var", " h = ", "this", ".formatTime(", "Math", ".floor(duration / ", "3600", ") % ", "24", ")\r\n      ", "var", " d = ", "this", ".formatTime(", "Math", ".floor(duration / ", "3600", " / ", "24", "))\r\n      ", "var", " time = ", "`", "${d}", ":", "${h}", ":", "${m}", ":", "${s}", "`", "\r\n      ", "//写入", "\r\n      ", "this", ".setData({\r\n        ", "timeDisplay", ": time\r\n      })\r\n      ", "return", " ", "true", "\r\n    },\r\n    ", "//倒计时", "\r\n    countDown: ", "function", "(", "duration", ") ", "{\r\n      ", "//有没有倒计时的必要.第一次展示时间(这个很重要)", "\r\n      ", "var", " canCountDown = ", "this", ".setTime(duration)\r\n\r\n      ", "if", " (canCountDown === ", "true", ") {\r\n        ", "var", " intervalId = setInterval(\r\n          ", "function", "(", ") ", "{\r\n            ", "//清除计时器", "\r\n            ", "if", " (", "this", ".data.duration <= ", "0", ") {\r\n              ", "this", ".stopInterval(intervalId)\r\n            }\r\n            ", "this", ".setData({\r\n              ", "duration", ": ", "this", ".data.duration - ", "1", "\r\n            })\r\n\r\n            ", "this", ".setTime(", "this", ".data.duration)\r\n          }.bind(", "this", "),\r\n          ", "1000", "\r\n        )\r\n\r\n        ", "this", ".intervalId = intervalId\r\n      }\r\n    },\r\n    ", "//初始化剩余时间", "\r\n    initDuration: ", "function", "(", "newVal", ") ", "{\r\n      ", "if", " (", "this", ".intervalId) {\r\n        ", "//若有计时器，清除", "\r\n        ", "this", ".stopInterval(", "this", ".intervalId)\r\n      }\r\n      ", "this", ".setData({\r\n        ", "duration", ": ", "this", ".data.durationInit\r\n      })\r\n      ", "this", ".countDown(newVal)\r\n    },\r\n    ", "//清除计时器", "\r\n    stopInterval: ", "function", "(", "intervalId", ") ", "{\r\n      ", "if", " (intervalId != ", "null", ") {\r\n        clearInterval(intervalId)\r\n        ", "this", ".intervalId = ", "null", "\r\n      }\r\n    },\r\n    ", "//格式化时间", "\r\n    formatTime(time) {\r\n      ", "return", " time < ", "10", " ? ", "`0", "${time}", "`", " : ", "`", "${time}", "`", "\r\n    }\r\n  }\r\n})\r\n", "最后想吐槽一下W3School，随着学习的深入，发现W3School的坑真多，强烈建议不要看W3School学前端，要看MDN文档。可能很多人的前端启蒙就是W3School，我也是。名字跟W3C很像，还以为是非常专业的网站，然而后来发现跟W3C并没有什么关系。W3School在baidu搜索排名非常高，被坑了，baidu也是同谋。现在早已拥抱google，清爽！", "下面就拿setInterval的说明做例子，对比一下MDN和W3School，就知道后者有多坑了。", "通过上面3张图片，可以看出", "1. W3School含糊其辞，解释不清楚，不详细。用的时候容易出问题", "W3School：周期性执行...请告诉我如果先执行了回调函数，再等待1秒，再执行回调函数，这算不算得上周期性？？", "MDN：详细指出", "函数的每次调用会在该延迟之后发生", "2. 不推荐的用法没有指出，文档更新慢，权威性极低", "W3School：连举的例子都是不推荐的用法，用code代码串。。。", "MDN：", "详细指出使用code不推荐，不仅如此，还发散性指出原因和eval()一样", "，真的很贴心很友好了", "以上图片均来源于MDN和W3School", "在最后，感谢踩过的坑，让我成长！初来乍到，多多关照，希望能坚持写技术博文。", " "]}
{"title": "开发笔记：使用 mpvue 开发斗图小程序", "author": "Rolan", "pub_time": "2018-7-24 00:15", "content": [" \n                     \n                    ", "之前用过 ", "wepy", " 框架写了个", "小程序", " ", "GitHub - yshkk/shanbay-mina: 基于 wepy 框架的 “扇贝阅读” 微信小程序", " ，感觉写法上类似 vue，但不那么彻底。现在美团点评发布的 ", "mpvue", " 支持开发者可以用 vue 的语法开发微信小程序，正好有强需求需要一个斗图小程序，所以就尝试了下。", "项目地址", "GitHub - yshkk/bqb-mpvue: 基于 mpvue 的表情包斗图微信小程序", "扫码体验", "截图", "开发细节和坑", "使用 ", "iView Weapp", " 组件库", "相关代码 pages/index/main.js 第 8 行", "将组件库的 dist 目录拷贝到自己项目 static 目录，然后在需要用到组件的页面配置 ", "usingComponents", " 即可。开发期间可能对组件的样式不太满意，或者一些蜜汁问题（比如 input 下边框突然消失 ", "issue", " ），要改的话方式非常诡异 ", "相关 issue", " ，所以粗暴点的方式就是直接改组件库里的 wxss 文件。", "v-show 和 v-model 不好使", "相关代码 pages/index/index.vue 第 4 行", "关于 ", "v-show", " 相关 ", "issue", " ，所以只能用 ", "v-if", " 替代。使用 ", "v-if", " 会销毁不显示的组件，但有个场景是期望保留原来的组件，因此只能曲线救国在组件外层包一个 ", "< view >", " 使用 ", ":style=\"{display?condition?'block':'none'}\"", " 的方式（其实最好是用 keep-alive 的方法，可惜 mpvue 不支持）。", "v-model", " 就很奇怪了，好像 input 不能双向绑定，原因是自定义组件就没有支持 ", "v-model", " ，所以得手动 update data。同理使用组件库 input 后不能使用 ", "v-focus", " 。(相关 ", "issue", " )", "模板语法里不能调用 methods 方法", "相关代码 components/homppage.vue 第 52 行", "可以说是血坑了，一直以为我使用姿势有误，费了好长时间。后来才从 ", "articles / 美团小程序框架 mpvue 蹲坑指南. md at master · noahlam/articles · GitHub", " 看到原来这是 mpvue 不支持。 当时的场景是这样的： 在图片列表里，给被用户 “收藏” 过的图片加个额外的 className，该 className 可以给图片加个粉色边框，这样就能在图片列表中一眼看到哪些是被收藏过的。data 里有一个表示所有图片的数组 ", "imageList", " 和一个表示收藏列表的数组 ", "favoriteList", " 。起初的写法是", "<image v-", "for", "=", "\"img in imageList\"", " ", ":src=", "\"img.url\"", " ", ":class=", "\"isFavorite(img.url)?'image-favorite':'image'\"", "\r\n复制代码", "其中 ", "isFavorite", " 是在 methods 里的一个方法，判断当前图片 url 是否在 ", "favoriteList", " 里。然而这样写一直不 work，后来只能换个方案：在 computed 里跟据 ", "imageList", " 和 ", "favoriteList", "计算出 一个叫 ", "imageListWithFavorite", " 的数组，遍历这个数据即可:joy: 虽然很丑陋但是还能用。", "将用户收藏同步到本地存储", "相关代码 components/homppage.vue 第 63 行", "用户收藏的表情会放到微信提供的 storage，类似浏览器的 localstorage，这样在关闭小程序以后下次来还能看到自己的收藏，因此在组件需要 watch ", "favoriteList", " 的变更并调用 ", "wx.setStorage", " 方法。但是不知为何直接 watch ", "favoriteList", " 并不会触发相应函数，而 watch ‘favoriteList.length’就能触发，希望有大佬能指点下。", "watch: {\r\n    ", "'favoriteList.length'", ": {\r\n      ", "// 将变化更新到本地存储", "\r\n      handler: function (", "val", ", oldval) {\r\n        ", "this", ".updateStorage({method: ", "val", " > oldval ? ", "'ADD'", " : ", "'DELETE'", "})\r\n      }\r\n    }\r\n  }\r\n复制代码", "表情包图片制作", "相关代码 pages/maker/index.vue", "思路是初始化一个 canvas，将表情模版（一张图片，url 从跳转过来的页面的 query 里取得）绘制到 canvas 上，用户打字 / 设置颜色字体 的时候调用 ", "updateCanvas", " 。最后调用 ", "wx.canvasToTempFilePath", " 方法输出成图片。 关键代码如下", "ctx = wx.createCanvasContext(", "'maker'", ") ", "// 选择当前 canvas", "\r\n  ...\r\n\tupdateCanvas () {\r\n      ctx.drawImage(", "this", ".path, ", "0", ", ", "0", ", ", "300", ", ", "300", ") ", "//path 为当前表情包的路径", "\r\n      ctx.setTextAlign(", "'center'", ") ", "// 必须每次在 updateCanvas 重新设置，否则模拟器上生效但真机下不会生效", "\r\n      ctx.setFontSize(", "this", ".fontSize)\r\n      ctx.setFillStyle(", "this", ".currentColor)\r\n      ctx.fillText(", "this", ".txt, ", "this", ".x, ", "this", ".y)\r\n      ctx.draw()\r\n    },\r\n复制代码", "有几个小坑：", "将图片绘制到 canvas 时指定的图片不能是一个远端图床的链接，必须先本地下载下来（调用 ", "wx.getImageInfo", " 获取图片，得到本地一个临时 path）才能绘制。", "canvas 指定的大小单位是 px，而用 css 控制的单位是 rpx（mpvue 用了 ", "px2rpx-loader", " ，就算在 css 里写成 px 也会被编译成 rpx）。", "小程序 canvas 的 ", "save", " 和 ", "restore", " 功能在这里很鸡肋，每次都需要完全重绘一次。特别是用户拖动文字更新文字坐标的功能， ", "touchmove", " 事件一直触发，就一直更新 canvas，小程序里没有 ", "requestAnimationFrame", " 的方法，所以就自己得~~ 从网上找~~ 封装一个，在拖动时起到节流的效果。", "canvas 输出的图片只支持 jpg 或者 png，因此即使用 gif 图的模版也只能生成静态的表情包，残念。", "总结", "大体上使用 mpvue 的体验还是挺好的。mpvue 和 wepy 的写法上比较类似，mpvue 对 vue 开发者来说更友好容易上手，wepy 更接近于原生小程序。虽然框架的出现屏蔽了一些原生小程序写起来很丑陋的地方， ", "但是不管用什么框架，原生小程序的文档还是需要掌握的", " ，有一大堆的坑等着要踩，有时候不得不从编译出的文件里面找原因。", " "]}
{"title": "微信小程序调起键盘性能优化", "author": "Rolan", "pub_time": "2018-7-25 00:06", "content": [" \n                     \n                    ", "在", "小程序", "中，我们经常有调起键盘的操作场景，但是在不同的场景下解决方案不尽相同，还是需要具体问题具体分析。", "需求分析", "最近在项目中有一个需求，是从列表页点击评论按钮进入详情页时，在加载完页面后自动调起键盘进入评论状态。从需求来看，我们应该在onReady函数中调起键盘，因为onReady函数是在页面初次渲染完成时被调用。但是在实践中我们发现，对于一些配置不好的手机，其加载页面速度较慢，在onReady函数调用时页面并没有渲染完毕，就会导致placeholder和input组件位置错乱的现象。其本质原因是，onReady生命周期函数并不能在调用时承若已经将页面渲染完成了。（尽管文档中描述是已经完成了。）", "之前的操作是在onReady生命周期函数中调起键盘。", "this", ".setData", "({ ", "focus", ": true })\r\n复制代码", "发现这个问题后做了相应的延迟处理", "setTimeout(", "()", " =>", " {\r\n  ", "this", ".setData({ focus: ", "true", " })\r\n}, ", "300", ")\r\n复制代码", "但这是治标不治本的方法，手机性能好的用户会无谓的等待300毫秒，而手机性能很差的用户等待300毫秒也不一定就能解决这个问题。", "解决思路", "那么既然小程序并没有提供给我们一个理想的渲染结束后的回调函数，那么我们就换个思路： 使用短轮询来处理，当页面渲染完成后才调起键盘的操作。", "既然要使用短轮询，那么我们去轮询什么呢？什么标志代表着页面渲染完成了呢？在这里，我是使用 ", "wx.createSelectorQuery()", " 方法，它会返回一个SelectorQuery对象实例，在这个实例上调用select方法选择我想要去轮询的节点，在回调函数中判断参数是否为 ", "null", " 。如果返回了监控的节点信息，那么说明已经渲染完成。这时就可以进行键盘调起操作了。", "let", " timer = setInterval(", "()", " =>", " {\r\n  wx.createSelectorQuery().select(", "'#comment-section'", ").boundingClientRect(", "rect", " =>", " {\r\n    ", "if", " (rect !== ", "null", " && timer !== ", "null", ") {\r\n      clearInterval(timer)\r\n      timer = ", "null", "\r\n      ", "this", ".setData({ ", "focus", ": ", "true", " })\r\n    }\r\n  }).exec()\r\n}, ", "50", ")\r\n复制代码", "在此之上，如果我们只粗暴的让 ", "focus", " 为 ", "true", " 并不是个明智的做法。", "在调起键盘时默认页面会上推，如果在评论很少的情况下这样的体验并不好。所以需要判断一个高度，超过这个值就上推，没超过就不上推。这个值视实际情况而定。 上推的操作是由input组件的 ", "adjust-position", " 属性决定，为true则上推，否则则不上推。这时回调返回的参数中的节点信息就可以派上用场了。", "// 在this.setData({ focus: true })前对节点高度进行判断", "\r\n", "if", " (rect.height < ", "500", ") ", "this", ".setData({ push: ", "false", " })\r\n", "else", " ", "this", ".setData({ push: ", "true", " })\r\n复制代码", "onBlur函数问题", "在实际的操作中，我们发现在键盘被调起后会有概又自动收回。经过排查发现时onBlur函数的问题，在onBlur函数中，我们手动的设置 ", "focus", " 为 ", "false", " ，但其实并不需要这一步操作，反而带来了副作用。在我们去除了这部分代码后，键盘自动收起的问题得到了解决。", "封装起来", "虽然我们完成了这次任务的需求，但是显而易见的，这样的任务在未来肯定还会再次出现。所以机智的我们应该赶快把整套流程封装起来，以便下次直接调用。", "那么这时我们使用的方式就是这样的：", "const", " Util = ", "require", "(", "\"xxx\"", ") ", "// 引入封装的库", "\r\n\r\n", "/**\r\n * 生命周期函数--监听页面初次渲染完成\r\n */", "\r\nonReady: ", "function", " (", ") ", "{\r\n  Util.onTotalReady(", "'#comment-section'", ", ", "50", ", rect => {\r\n    ", "if", " (rect.bottom < ", "500", ") ", "this", ".setData({ ", "push", ": ", "false", " })\r\n    ", "else", " ", "this", ".setData({ ", "push", ": ", "true", " }}\r\n    ", "this", ".setData({ ", "focus", ": ", "true", " })\r\n  })\r\n}\r\n复制代码", "小结", "在解决键盘调起的这个过程中我们可以看出微信小程序开发流程的简陋，这个问题的出现本质上是小程序提供给我们的生命周期函数的不够准确。否则在页面渲染完成的情况下我怎么会拿不到节点信息呢？像react中的componentWillMount生命周期函数中就不会出现这样的问题，所以希望小程序能再变强大一些，也让我们少写一点这种hack代码。", " "]}
{"title": "多人对战游戏开发实例之《组队小鸡射击》（附源码）", "author": "Rolan", "pub_time": "2018-7-24 00:37", "content": [" \n                     \n                    ", "前言：该游戏项目主要是基于前端引擎Cocos Creator开发，涉及后端联网的部分，则通过接入Matchvs SDK完成快速开发工作。", "准备工作", "Matchvs JavaScript SDK ", "下载地址", "Matchvs JavaScript 的Cocos Creator ", "插件使用手册", "Cocos Creator ", "下载地址", "《组队小鸡射击》玩法简介：", "双方通过控制各自小鸡，通过不断点击屏幕进行空中飞行射击，被击中者将消耗以爱心为单位的生命值，游戏支持四人同时实时对战。", "点击并拖拽以移动​", "实现步骤", "游戏实现部分可拆分为三个步骤来实现：用户登录、随机匹配和创建房间及同屏游戏。", "用户登录", "​使用Cocos Creator(以下简称CC)创建游戏登录场景", "​ 使用CC 拖动控件, 还原设计稿 , 依托CC的良好的工作流,使得这部分的工作可以由游戏策划或者UI设计者来完成,程序开发者只需要在场景中挂载相应的游戏逻辑脚本. 举个例子,在登录按钮挂在一个uiLogin.js的脚本完成用户登录功能.", "uilogin.fire", "新建js脚本文件", "选中场景任一控件", "添加组件,选中刚新建的脚本,", "在脚本的onLoad函数中给按钮添加点击监听,触发登录操作", "uiLogin.js", "​", "onLoad() {", "this", ".nodeDict[", "\"start\"", "].on(", "\"click\"", ", ", "this", ".startGame, ", "this", ");", "},", "startGame() {", "Game", ".GameManager", ".matchVsInit", "();", "}", "实现this.startGame函数. 登录之前需要初始化Matchvs SDK:", "uiLogin.js", "uiLogin.js", "var uiPanel = require(\"uiPanel\");", "cc.Class({", "extend", "s:", " uiPanel,\r\npropertie", "s:", " {},", "​", "onLoad() {\r\n    ", "this", "._super();\r\n    ", "this", ".nodeDict[", "\"start\"", "].on(", "\"click\"", ", ", "this", ".startGame, ", "this", ");\r\n},", "​", "startGame", "() {\r\n    ", "Game", ".GameManager", ".matchVsInit", "();\r\n}", "});", "​", "​", "Game.GameManager.js", "matchVsInit: function() {", "mvs.response.initResponse = ", "this", ".initResponse.bind(", "this", ");\r\nmvs.response.errorResponse = ", "this", ".errorResponse.bind(", "this", ");\r\n", "// 用户登录之后的回调", "\r\nmvs.response.loginResponse = ", "this", ".loginResponse.bind(", "this", "); ", "​", "var ", "result", " = mvs.engine.init(mvs.response, GLB.channel, GLB.platform, GLB.gameId);\r\n", "if", " (", "result", " !== ", "0", ") {\r\n    console.", "log", "('初始化失败,错误码:' + ", "result", ");\r\n}", "}", "初始化需要的几个参数在Matchvs官网注册即可得到,注册地址 ", "http://www.matchvs.com", "channel:", " ", "'MatchVS'", ",\r\n", "platform:", " ", "'alpha'", ",\r\n", "gameId:", " ", "201330", ",\r\n", "gameVersion:", " ", "1", ",\r\n", "appKey:", " ", "'7c7b185482d8444bb98bc93c7a65daaa'", ",\r\n", "secret:", " ", "'f469fb05eee9488bb32adfd85e4ca370'", ",", "注册成功后,登录Matchvs游戏云,返回UserID,登录成功.", "gameManager.js", "​", "registerUserResponse: function(userInfo) {", "var", " deviceId = ", "'abcdef'", ";\r\n", "var", " gatewayId = ", "0", ";\r\nGLB.userInfo = userInfo;", "​", "console.", "log", "('开始登录,用户Id:' + userInfo.", "id", ")", "​", "var ", "result", " = mvs.engine.login(\r\n    userInfo.", "id", ", userInfo.token,\r\n    GLB.gameId, GLB.gameVersion,\r\n    GLB.appKey, GLB.secret,\r\n    deviceId, gatewayId\r\n);\r\n", "if", " (", "result", " !== ", "0", ") {\r\n    console.", "log", "('登录失败,错误码:' + ", "result", ");\r\n}", "},", "​", "loginResponse: function(info) {", "if", " (info.status !== ", "200", ") {\r\n    ", "console", ".log(", "'登录失败,异步回调错误码:'", " + info.status);\r\n} ", "else", " {\r\n    ", "console", ".log(", "'登录成功'", ");\r\n    ", "this", ".lobbyShow();\r\n}", "},", "随机匹配和创建房间", "使用CC创建大厅场景(uiLobbyPanel.fire)给用户选择匹配方式,创建匹配场景(uiMatching1v1.fire) 给用户反馈比配进度", "和登录功能的实现步骤类似:写一个 uiMatching1v1.js脚本挂在到场景中的控件上.", "uiMatching1v1.js", "joinRandomRoom: function() {", "var ", "result", " = mvs.engine.joinRandomRoom(GLB.MAX_PLAYER_COUNT, '');\r\n", "if", " (", "result", " !== ", "0", ") {\r\n    console.", "log", "('进入房间失败,错误码:' + ", "result", ");\r\n}", "},", "通过监听joinRoomResponse和joinRoomNotify匹配结果", "gameManager.js", "joinRoomResponse: function(status, roomUserInfoList, roomInfo) {", "if", " (", "status", " ", "!== 200) {", "\r\n    console.", "log", "(", "\"失败 joinRoomResponse:\"", " + ", "status", ");\r\n    ", "return", ";\r\n}\r\nvar ", "data", " = {\r\n    ", "status", ": ", "status", ",\r\n    roomUserInfoList: roomUserInfoList,\r\n    roomInfo: roomInfo\r\n}\r\n// 把事件发给关心这个事件的节点脚本\r\nclientEvent.dispatch(clientEvent.eventType.joinRoomResponse, ", "data", ");", "},", "​", "joinRoomNotify: function(roomUserInfo) {", "var", " ", "data", " = {\r\n    ", "roomUserInfo", ": ", "roomUserInfo", "\r\n}", "\r\n", "clientEvent", ".dispatch(clientEvent.eventType.joinRoomNotify, ", "data", ");", "},", "同屏游戏 , 实现游戏同步", "还是按照上面的套路,新建场景(uiGamePanel.fire),在playerManager.js中,加载了player.js.在player.js中,攻击的动作使用Matchvs 的 sendEventEx发出,", "player.js", "hurt: function(murderId) {", "var msg = {\r\n", "    action:", " GLB.PLAYER_HURT_EVENT,\r\n", "    playerId:", " this.userId,\r\n", "    murderId:", " murderId\r\n};\r\nGame.GameManager.sendEventEx(msg);", "}", "另一方的客户端收到后处理事情;", "gameManager.js", "​", "// 玩家行为通知--", "sendEventNotify: function(info) {", "if", " (info.cpProto.indexOf(GLB.PLAYER_HURT_EVENT) >= ", "0", ") {\r\n    ", "if", " (Game.GameManager.gameState !== GameState.Over) {\r\n        player = Game.PlayerManager.getPlayerByUserId(cpProto.playerId);\r\n        ", "if", " (player) {\r\n            player.hurtNotify(cpProto.murderId);\r\n        }\r\n        ", "// 检查回合结束--", "\r\n        ", "var", " loseCamp = Game.PlayerManager.getLoseCamp();\r\n        ", "if", " (loseCamp != ", "null", ") {\r\n            Game.GameManager.gameState = GameState.Over\r\n            ", "if", " (GLB.isRoomOwner) {\r\n                ", "this", ".sendRoundOverMsg(loseCamp);\r\n            }\r\n        }\r\n    }\r\n}", "}", "​", "开发完成后， 再通过CC的微信小游戏一键发布功能上线微信即可。 ", " "]}
{"title": "百度智能小程序介绍", "author": "Rolan", "pub_time": "2018-7-6 14:17", "content": [" \n                     \n                    ", "手百智能", "小程序", "介绍", "智能小程序是一种新的开放能力，开发者可以快速地开发一个智能小程序。通过搜索，用户可以在手百 App 内被便捷地获取和传播。", "框架概述", "SWAN App 基本开发思路类似于前端开发，并增强调用大量端能力，性能体验优于普通 Web 。上层架构基于 JS 开发，可以辅助开发者进行良好得开发。", "SWAN App 为开发者提供了 MVVM 的开发方式。JS 状态的变更引起视图的变化，视图的变更也可以回馈到逻辑层的状态中，开发者开发更加方便。", "目录结构", "工程的工作目录中包含以下文件：", "|____app.css", "|____app.json", "|____project.swan.json", "|____pages", "|       |____detail", "|       |        |____detail.css", "|       |        |____detail.swan", "|       |        |____detail.js", "|       |____index", "|       |        |____index.js", "|       |        |____index.swan", "|       |        |____index.css", "|____app.js", "我们看到以下几类的文件：", "1、 .json 为后缀的 JSON 配置文件，这个文件配置了 SWAN 智能小程序所有页面的路径和界面展现样式等；", "2、 .swan 结尾的 SWAN 模板文件，这个文件是用来描述当前这个页面的文件结构，类似于网页网页中的 HTML 文件；", "3、 .css 结尾的 CSS 样式文件，描述页面样式；", "4、 .js 结尾的 JS 文件，处理这个页面和用户的交互。", " "]}
{"title": "weapp-cookie：一行代码让微信小程序支持 cookie", "author": "Rolan", "pub_time": "2018-7-25 00:12", "content": [" \n                     \n                    ", "一行代码让微信", "小程序", "支持 cookie，传送门： ", "github", "Intro", "微信原生的 wx.request 网络请求接口并不支持传统的 Cookie，但有时候我们现有的后端接口确于依赖 Cookie（比如服务器用户登录态），这个库可用一行代码为你的小程序实现 Cookie 机制，以保证基于 cookie 的服务会话不会失效，与 web 端共用会话机制", "Install", "npm", " install weapp-cookie --save\r\n\r\n", "# 将 npm 包复制到 vendor 文件夹，避免小程序可能不能找到文件（tips：使用 wepy/mpvue 等框架无需此步）", "\r\ncp -rf .", "/node_modules/", " .", "/vendor/", "\r\n复制代码", "Usage", "在小程序根目录的 app.js 一行代码引入即可", "// app.js", "\r\n", "import", " ", "'./vendor/weapp-cookie/index'", "\r\n\r\n", "// tips: 使用 wepy/mpvue 可以直接在入口 js 引入 weapp-cookie 模块", "\r\n", "// import 'weapp-cookie'", "\r\n\r\nApp({\r\n    ", "onLaunch", ": ", "function", " (", ") ", "{ }\r\n    ", "// ...", "\r\n})\r\n复制代码", "原来的 wx.request 调用方式保持不变，引入后 weapp-cookie 会在底层自动代理 wx.request 的接口访问，以支持 cookie 存储和发送", "// pages/home/index.js", "\r\n\r\n", "Page", "({\r\n    ", "onLoad", ": function () {\r\n        wx.request({\r\n            ", "url", ": ", "'https://example.com/login'", ",\r\n            ", "data", ": {\r\n                ", "username", ": ", "'admin'", ",\r\n                ", "password", ": ", "'123456'", "\r\n            },\r\n            ", "success", ": function (res) {\r\n                ", "/*\r\n                 * 接口调用成功后 weapp-cookie 会自动保存后端发送的所有Cookie（比如：SessionID）\r\n                 * 并在后续的所有请求中带上，以保证基于 cookie 的服务器会话机制不会失效，\r\n                 * 实现与 web 端共用会话机制（无需再手动维护 3rd_session_key） \r\n                 */", "\r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码", "如果对你有用，欢迎 star ^_^", " "]}
{"title": "微信小程序车牌键盘", "author": "Rolan", "pub_time": "2018-7-24 00:21", "content": [" \n                     \n                    ", "项目背景", "公司要做一个停车场微信", "小程序", "，支持临时车预支付以及支付记录查询等功能,其中涉及车牌输入的功能，为了提升用户体验，避免繁琐的输入，决定自己写一个键盘。", "效果图如下", "省份简写键盘如下:", "省份简写键盘", "英文简写键盘如下:", "英文简写键盘", "源代码", "目录结构", "目录结构", "wxml文件内容", "<view wx:", "if", "=", "\"{{isShow}}\"", " ", "class", "=", "\"vehicle-panel\"", " style=", "\"height:430rpx;background-color:{{backgroundColor}}\"", ">", "  <!--省份简写键盘-->", "  <block wx:", "if", "=", "\"{{keyBoardType === 1}}\"", ">", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button'", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "=", "\"{{keyVehicle1}}\"", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button'", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "=", "\"{{keyVehicle2}}\"", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button'", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "=", "\"{{keyVehicle3}}\"", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row-last\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button vehicle-panel-row-button-last'", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "=", "\"{{keyVehicle4}}\"", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "    </view>", "  </block>", "  <!--英文键盘  -->", "  <block wx:", "else", ">", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button vehicle-panel-row-button-number'", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "=", "\"{{keyNumber}}\"", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"item\"", ">{{item}}</view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button'", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "=", "\"{{keyEnInput1}}\"", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "-index=", "\"idx\"", "  wx:key=", "\"idx\"", ">{{item}}</view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button'", " style=", "\"border:{{buttonBorder}}\"", " wx:", "for", "=", "\"{{keyEnInput2}}\"", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "      <view hover-", "class", "=", "\"vehicle-hover\"", " style=", "\"border:{{buttonBorder}}\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button vehicle-panel-row-button-img'", ">", "        <image src=", "'./delete.svg'", " ", "class", "=", "'vehicle-en-button-delete'", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"delete\"", " mode=", "'aspectFit'", ">删除</image>", "      </view>", "    </view>", "    <view ", "class", "=", "\"vehicle-panel-row-last\"", ">", "      <view hover-", "class", "=", "\"vehicle-hover\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button vehicle-panel-row-button-last'", " bindtap=", "'vehicleTap'", " style=", "\"border:{{buttonBorder}}\"", " data-", "value", "=", "\"{{item}}\"", " wx:", "for", "=", "\"{{keyEnInput3}}\"", " wx:", "for", "-index=", "\"idx\"", " wx:key=", "\"idx\"", ">{{item}}</view>", "      <view hover-", "class", "=", "\"vehicle-hover\"", " style=", "\"border:{{buttonBorder}}\"", " hover-start-time=", "\"10\"", " hover-stay-time=", "\"100\"", " ", "class", "=", "'vehicle-panel-row-button vehicle-panel-ok'", " bindtap=", "'vehicleTap'", " data-", "value", "=", "\"ok\"", ">确定</view>", "    </view>", "  </block>", "</view>", "json文件", "{", "  ", "\"component\"", ": ", "true", "}", "js文件", "Component({", " ", "  ", "externalClasses", ": [", "'v-panel'", "],", " ", "  ", "properties", ": {", "    ", "isShow", ": {", "      ", "type", ": ", "Boolean", ",", "      ", "value", ": ", "false", ",", "    },", "    ", "buttonBorder", ": {", "      ", "type", ": ", "String", ",", "      ", "value", ": ", "\"1px solid #ccc\"", "    },", "    ", "backgroundColor", ":{", "      ", "type", ": ", "String", ",", "      ", "value", ": ", "\"#fff\"", "    },", "    ", "//1为省份键盘，其它为英文键盘", "    keyBoardType: {", "      ", "type", ": ", "Number", ",", "      ", "value", ": ", "1", ",", "    }", "  },", "  ", "data", ": {", "    ", "keyVehicle1", ": ", "'陕京津沪冀豫云辽'", ",", "    ", "keyVehicle2", ": ", "'黑湘皖鲁新苏浙赣'", ",", "    ", "keyVehicle3", ": ", "'鄂桂甘晋蒙吉闽贵'", ",", "    ", "keyVehicle4", ": ", "'粤川青藏琼宁渝'", ",", "    ", "keyNumber", ": ", "'1234567890'", ",", "    ", "keyEnInput1", ": ", "'QWERTYUIOP'", ",", "    ", "keyEnInput2", ": ", "'ASDFGHJKL'", ",", "    ", "keyEnInput3", ": ", "'ZXCVBNM'", ",", "  },", "  ", "methods", ": {", "    ", "vehicleTap", ": ", "function", " (", "event", ") ", "{", "      ", "let", " val = event.target.dataset.value;", "      ", "switch", " (val){", "        ", "case", " ", "'delete'", ":", "          ", "this", ".triggerEvent(", "'delete'", ");", "          ", "this", ".triggerEvent(", "'inputchange'", ");", "        ", "break", ";", "        ", "case", " ", "'ok'", ":", "          ", "this", ".triggerEvent(", "'ok'", ");", "        ", "break", ";", "        ", "default", ":", "          ", "this", ".triggerEvent(", "'inputchange'", ", val);", "      }", "    },", "  }", "});", "wxss文件", ":host", " {", "  ", "width", ": ", "100%", ";", "}", ".vehicle-panel", " {", "  ", "width", ": ", "100%", ";", "  ", "position", ": fixed;", "  ", "bottom", ": ", "0", ";", "  ", "display", ":flex;", "  ", "flex-direction", ":column;", "  ", "justify-content", ":center;", "  ", "z-index", ": ", "1000", ";", "}", ".vehicle-panel-row", " {", "  ", "display", ": flex;", "  ", "justify-content", ": space-between;", "  ", "align-items", ": center;", "}", ".vehicle-panel-row-last", "{", "  ", "display", ": flex;", "  ", "justify-content", ": space-between;", "  ", "align-items", ": center;", "}", ".vehicle-panel-row-button", " {", "  ", "background-color", ": ", "#fff", ";", "  ", "margin", ": ", "5", "rpx;", "  ", "padding", ": ", "5", "rpx;", "  ", "width", ": ", "80", "rpx;", "  ", "height", ": ", "80", "rpx;", "  ", "text-align", ": center;", "  ", "line-height", ": ", "80", "rpx;", "  ", "border-radius", ": ", "10", "rpx;", "}", ".vehicle-panel-row-button-number", " {", "  ", "background-color", ": ", "#eee", ";", "}", ".vehicle-panel-row-button-last", " {", "  ", "width", ": ", "90", "rpx;", "  ", "height", ": ", "90", "rpx;", "  ", "line-height", ": ", "90", "rpx;", "}", ".vehicle-hover", " {", "  ", "background-color", ": ", "#ccc", ";", "}", ".vehicle-panel-row-button-img", " {", "  ", "display", ": flex;", "  ", "justify-content", ": center;", "  ", "align-items", ": center;", "}", ".vehicle-en-button-delete", " {", "  ", "width", ": ", "55", "rpx;", "  ", "height", ": ", "85", "rpx;", "}", ".vehicle-panel-ok", " {", "  ", "background-color", ": ", "#0F4BA1", ";", "  ", "color", ": ", "#fff", ";", "  ", "width", ": ", "150", "rpx;", "  ", "height", ": ", "80", "rpx;", "}", "使用方式", "示例", "<v-panel ", "is", "-show=", "\"{{isShow}}\"", " bindok=", "\"inputOk\"", " binddelete=", "\"inputdelete\"", " bindinputchange=", "\"inputChange\"", " ", "key", "-board-type=", "\"{{keyBoardType}}\"", " backgroundColor=", "\"white\"", " />\r\n", "属性", "属性名称", "类型", "默认值", "说明", "isShow", "布尔(boolean)", "false", "控制键盘是否显示,true显示，false不显示", "buttonBorder", "字符串(String)", "\"1px solid #ccc\"", "控制键盘按钮边框，同css border属性", "backgroundColor", "字符串(String)", "#fff", "控制键盘背景色,同css", "keyBoardType", "数字(Number)", "1", "控制键盘显示类型,1为省份简写,2为英文简写", "事件", "事件名称", "触发情况", "返回值", "delete", "删除按钮按下的时候触发", "微信事件", "ok", "确定按钮按下时触发", "微信事件", "inputchange", "输入按钮按下或者删除按钮按下时触发", "输入的值", "完毕!", "以上代码仅供大家学习交流", "相关推荐：", "在微信小程序中使用“随机键盘”", " "]}
{"title": "如何获得你的第一个智能小程序", "author": "Rolan", "pub_time": "2018-7-6 14:24", "content": [" \n                     \n                    ", "第一个智能", "小程序", "申请帐号", "使用百度帐号（没有百度帐号会自动创建）登录 ", "智能小程序开发者后台", "。", "登录成功后，选择类型、填写信息并提交相应的资料。", "提交完资料，等待审核。审核通过后，就可以拥有自己的智能小程序帐号。", "审核通过后，登录 ", "智能小程序开发者后台", " 。 打开“智能小程序首页”-“设置”-“开发设置”， 查看智能小程序的 AppID 。", "安装百度开发者工具", "下载百度开发者工具。 ", "Windows 内测下载地址", " | ", "Mac 内测下载地址", "。", "你的第一个智能小程序", "成功安装百度开发者工具后，打开后出现以下界面。用户可以新建项目或者打开现有智能小程序项目。", "新建项目需要开发者填写项目的名称、项目开发路径和 AppID 。信息校验无误后脚手架会自动生成智能小程序的初始化文件。", "如果开发者尚没有 AppID 可以点击 “注册”，注册 AppID 或者点击 “智能小程序” 选择体验模式，但体验模式下部分 API 可能无法正常调用。", "编译", "点击百度开发者工具上的编译按钮，可以在百度开发者工具的左侧模拟器界面看到这个智能小程序的表现，也可以点击预览按钮，通过百度APP的扫一扫在手机上体验你的第一个智能小程序。", " "]}
{"title": "小程序的这些坑你踩过吗？", "author": "Rolan", "pub_time": "2018-6-5 00:12", "content": [" \n                     \n                    ", "随着跳一跳小游戏和头脑王者的洗脑式盛行，", "小程序", "似乎向广大用户宣布，它要发力了。", "公司内部也越来越多小程序的需求，所以本人也慢慢地开发了好几个小程序的项目。下面我把自己在开发的过程中遇到的一些坑记录一下，防止以后再踩坑。", "1.模拟器和真机的差异", "在开发的过程中，在模拟器上表现得好好的，在真机上却出问题的例子数不胜数。譬如动画的使用，cover-view上面使用定位，在模拟器好好的，在真机却错乱等等等等。", "造成这些错乱主要是pc端和移动端不同的内核导致的。", "避坑方式：", "开发过程中，要时不时地用真机也看一下效果。", "2.view对本地图片的引用", "平时我们写页面，精彩会用一个标签，然后把图片写到该标签里面，直接引用，譬如下面这个例子：", "<view ", "class", "=", "\"icon\"", ">", "</", "view", ">", ".icon", "{\r\n", "color", ": ", "#1d1d1d", ";  \r\n", "background-image", ": url(../image/doll_user_bg.png);  \r\n", "width", "：50rpx;\r\n", "height", ":", "50", "rpx;\r\n}", "一眼看过去感觉没毛病，但是事实上你在模拟器或者真机上会发现，图片出不来。原因出在了相对路径的引用上。", "避坑的方法：", "（1）直接在标签的属性上添加图片的路径", "<view ", "class", "=", "'icon'", " style=", "\"background-image: url('../image/doll_user_bg.png');\"", ">", "</", "view", ">", "(2)使用绝对路径", ".icon", "{\r\n", "color", ": ", "#1d1d1d", ";  \r\n", "background-image", ": url(https://webtest.yystatic.com/project/yyDoll/mobile/image/doll_user_bg.png); \r\n", "width", "：50rpx;\r\n", "height", ":", "50", "rpx;\r\n}", "(3)直接使用image标签代替view标签", "<", "image", " ", "src", "=", "'../image/doll_user_bg.png'", ">", "</", "image", ">", "3.cover-view的样式", "由于小程序里面video标签的层级是最高的无法覆盖。所以cvoer-view应运而生。它就是用于盖在video标签上面，进行对video标签的周遭加以装饰的利器。", "然而，当我满心欢喜地以为这个标签很好用的时候，我遇到了很多奇奇怪怪的坑。", "例如在cover-view上面使用相对定位，当video标签大小发生变化的时候，cover-view上面的元素就乱七八糟。 又譬如圆角的不起效等等。 具体的问题大家可以在开发者社区看看。 ", "developers.weixin.qq.com/search?acti…", "避坑方法：尽量在cover-view上不使用定位，其他的bug只能等官方优化，大家谨慎使用。", "4.开发小程序的授权登录和公司账号互联", "如果只是一般的授权登录还是挺简单的，但是如果你要把你公司的账号体系和微信互联起来，这个流程就不简单了。", "我说一下我这边的流程是怎样的，首先我要向公司申请账号互联的appid，然后要经过多个部门的捆绑和审核,然后在公司开发者账号下绑定小程序appid。然后等账号那边的同事把账号打通，然后才实现了账号互联的授权登录。", "不同公司可能流程不大一样，写在这里只是作为步骤的记录，免得以后再踩坑。", "5.文字围绕", "当你在cover-view上面要是实现图文混排的文字围绕时，你会发现平时的一些方法都失效了。", "<", "cover", "-view><", "cover", "-image src=", "\"img.gif\"", " />文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕</", "cover", "-view>", "最常用的图片浮动，没有效果。使用定位，使用缩进，使用css3的属性等等，弄出来的效果放到真机上都无法正常显示图文混排的文字围绕。 目前暂时没有找到解决方法，有试过在cover-view实现的童鞋，求代码。", "6.webview和小程序的通讯", "刚开始看到小程序能内嵌webview的时候，内心是十分激动的。因为一些用小程序难以实现或者一些需要经常动态更改的页面，可以通过webview内嵌达到自己想要的效果。但是当我使用后，我发现坑爹了。webview和小程序竟然没有比较完善的通讯机制。 小程序和webview的通讯，例如一些参数的传递，目前仅仅是支持url的参数传递。例如：", "<", "web-view", " ", "src", "=", "\"https://mp.weixin.qq.com？password=12212&name=sasa&ticket=215328736dsadaadasdadaswuqsahkshakskahskahsakhsakshkasha327428749827487284729847382dsakhdlahdlahskjhdlkhlkadhldkhal\"", ">", "</", "web-view", ">", "如果你内嵌的webview页面是需要登录态的，你只能在url上面把那些账号密码，ticket什么的全传到参数上。很那个对不对。我在想如果有一天我要把一个复杂的form表单数据传过去那种酸爽。希望微信的童鞋能把通讯机制完善起来。", "7.input组件的文字居中问题", "input组件的宽度使用百分比，设置placeholder的文本text-align：canter，这时文字并不会正常居中。", "原来input设置百分比， placeholder就不支持设置 text-align样式了，想实现居中，就只能把input的长度写死。", "8.发送模板消息的限制", "如果用户在你小程序进行了某些操作，例如支付或者消耗了你们的虚拟的产品时，你可能需要发消息告诉用户提醒用户或者告知用户。这个时候就需要使用到模板消息了。", "当你想下发消息的时候你会发现，只有2种情况下你才能下发消息。", "1.支付", "当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发3条，多次支付下发条数独立，互相不影响）", "2.提交表单", "当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）", "++注：目前只有这2种情况才能下发消息，而且是有条数限制的，谨记了++。", "9.其他一些偶发的bug和小tips", "在开发小程序的时候，还会偶发一些小bug，举例一下：", "1.longpress 有时有效，有时候失灵", "2.canvas的drawImage频繁调动会导致页面卡顿，卡...卡...顿....", "3.getUserInfo的方法有时候会获取不到用户信息，建议可以使用轮询，获取到信息后再停止", "4.小程序如果想使用一些特殊字体，可以先把字体转成base64，再引入使用", "5.如果想做直播相关的需求，不要使用video标签，请使用live-player，可以做到更好的低时延", "6.开发小程序之前需要去看看小程序是否已经开放该品类，否则后面会被封（不要问我为什么知道=_=!!）", "Alone", "2018-05-27", " "]}
